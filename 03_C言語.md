# １．前処理（プリプロセッサ）
前処理（プリプロセッサ）やディレクティブについて詳しく説明します。

### 前処理（プリプロセッサ）とは

前処理（プリプロセッサ）は、CやC++プログラムのソースコードがコンパイルされる前に実行される一連の指示や処理のことです。プリプロセッサは、ソースコード内の特定の命令（ディレクティブ）に基づいてコードの変換や修正を行います。

### プリプロセッサの役割

1. **マクロの置換**: 定義されたマクロを展開して、コード内の特定の部分を置換します。
2. **ファイルのインクルード**: 外部ファイルの内容を現在のソースファイルに挿入します。
3. **条件付きコンパイル**: 特定の条件に基づいて、コードの一部をコンパイルするかどうかを決定します。
4. **エラーチェック**: プログラムの特定の条件が満たされない場合にエラーメッセージを出力します。

### ディレクティブとは

ディレクティブは、プリプロセッサに対する命令です。ディレクティブは常に`#`（シャープ）記号で始まり、その後に命令が続きます。ディレクティブはコンパイラに渡される前にプリプロセッサによって処理されます。

### 主要なプリプロセッサディレクティブ

以下に、主要なプリプロセッサディレクティブとその役割を簡単に説明します。

1. **#define**
   - マクロを定義します。例えば、定数や関数のようなコード片を定義できます。

   ```c
   #define PI 3.14
   #define SQUARE(x) ((x) * (x))
   ```

2. **#undef**
   - 以前に定義されたマクロを未定義にします。

   ```c
   #undef PI
   ```

3. **#include**
   - 外部のヘッダーファイルやソースファイルを現在のファイルに挿入します。

   ```c
   #include <stdio.h>
   #include "myheader.h"
   ```

4. **#if、#elif、#else、#endif**
   - 条件付きコンパイルを行います。特定の条件が満たされた場合にのみ、コードの一部をコンパイルします。

   ```c
   #if CONDITION
   // 条件が真の場合
   #elif ANOTHER_CONDITION
   // 別の条件が真の場合
   #else
   // どの条件も満たされない場合
   #endif
   ```

5. **#ifdef、#ifndef、#endif**
   - マクロが定義されているかどうかをチェックして、条件付きコンパイルを行います。

   ```c
   #ifdef DEBUG
   // DEBUGが定義されている場合
   #else
   // DEBUGが定義されていない場合
   #endif
   ```

6. **#error**
   - プリプロセッサがエラーメッセージを出力し、コンパイルを停止します。

   ```c
   #error "このコードはこのコンパイラではサポートされていません"
   ```

7. **#pragma**
   - コンパイラに特定の命令を与えます。内容はコンパイラ依存です。

   ```c
   #pragma once  // ヘッダーファイルの重複インクルードを防ぐ
   ```

8. **#line**
   - ソースコードの行番号やファイル名を設定します。

   ```c
   #line 100 "newfile.c"
   ```

### プリプロセッサの動作例

以下の簡単な例を見てみましょう。

```c
#define MAX 100

#if MAX > 50
    #include <stdio.h>
#endif

int main() {
    #ifdef MAX
        printf("MAX is defined and its value is %d\n", MAX);
    #else
        printf("MAX is not defined.\n");
    #endif
    return 0;
}
```

このコードでは、`MAX`が50より大きいため、`#include <stdio.h>`が有効になります。また、`MAX`が定義されているため、`printf`文がコンパイルされます。

プリプロセッサは、コードの柔軟性や移植性を高めるための強力なツールです。条件付きコンパイルを使用することで、異なる環境や設定に応じたコードを簡単に切り替えることができます。

条件付きコンパイルにおける`CONDITION`は、通常のC言語またはC++言語の定数式（定数表現）やマクロを使用して表現されます。具体的な例を見てみましょう。

### 定数式による条件

`CONDITION`には数値リテラルや定数式を使います。

```c
#define MAX 100

#if MAX > 50
    // このコードはMAXが50より大きい場合にコンパイルされる
    printf("MAX is greater than 50\n");
#else
    // このコードはMAXが50以下の場合にコンパイルされる
    printf("MAX is 50 or less\n");
#endif
```

### マクロによる条件

マクロが定義されているかどうかを条件にすることも一般的です。

```c
#define DEBUG

#ifdef DEBUG
    // このコードはDEBUGが定義されている場合にコンパイルされる
    printf("Debug mode is enabled\n");
#else
    // このコードはDEBUGが定義されていない場合にコンパイルされる
    printf("Debug mode is disabled\n");
#endif
```

### 複数の条件を組み合わせる

`#if`ディレクティブでは複数の条件を組み合わせて使うこともできます。

```c
#define VERSION 2

#if VERSION == 1
    printf("Version 1\n");
#elif VERSION == 2
    printf("Version 2\n");
#else
    printf("Unknown version\n");
#endif
```

### 定義されているマクロの値を条件にする

マクロが特定の値を持つかどうかを条件にすることも可能です。

```c
#define LEVEL 10

#if LEVEL > 5
    // このコードはLEVELが5より大きい場合にコンパイルされる
    printf("Level is greater than 5\n");
#else
    // このコードはLEVELが5以下の場合にコンパイルされる
    printf("Level is 5 or less\n");
#endif
```

### ヘッダーファイルのガードマクロ

ヘッダーファイルの多重インクルードを防ぐために、以下のように`#ifndef`、`#define`、`#endif`を組み合わせることが一般的です。

```c
#ifndef MYHEADER_H
#define MYHEADER_H

// ヘッダーファイルの内容

#endif /* MYHEADER_H */
```

この例では、`MYHEADER_H`というマクロが定義されていない場合にのみ、ヘッダーファイルの内容が挿入されます。2回目以降のインクルードでは、`MYHEADER_H`が既に定義されているため、ヘッダーファイルの内容は無視されます。

これらの方法を用いることで、条件付きコンパイルを柔軟に実現できます。状況に応じて適切な条件を設定することで、コードの可読性やメンテナンス性を向上させることができます。

# ２．externについて
`extern`はC言語およびC++言語において、変数や関数が別のファイルで定義されていることを示すキーワードです。このキーワードは主にグローバル変数や関数を別のファイルから参照する際に使用されます。`extern`を使うことで、プログラムの異なる部分が同じ変数や関数を共有することができます。

### 基本的な使い方

#### 変数の宣言と定義

変数の宣言と定義の違いを理解することが重要です。

- **定義**: 変数のメモリを実際に確保します。
- **宣言**: 変数がどこかで定義されていることを知らせますが、メモリは確保しません。

例を見てみましょう。

ファイル1 (`file1.c`):

```c
// 変数の定義
int globalVariable = 10;
```

ファイル2 (`file2.c`):

```c
#include <stdio.h>

// 変数の宣言
extern int globalVariable;

int main() {
    printf("globalVariable = %d\n", globalVariable);
    return 0;
}
```

ここで、`globalVariable`は`file1.c`で定義され、`file2.c`で宣言されています。このようにすることで、`file2.c`から`globalVariable`を参照できます。

#### 関数の宣言と定義

関数の場合も同様です。関数の定義と宣言を分けることができます。

ファイル1 (`file1.c`):

```c
#include <stdio.h>

// 関数の定義
void printMessage() {
    printf("Hello from file1!\n");
}
```

ファイル2 (`file2.c`):

```c
// 関数の宣言
extern void printMessage();

int main() {
    printMessage();
    return 0;
}
```

この例では、`printMessage`関数が`file1.c`で定義され、`file2.c`で宣言されています。`file2.c`から`printMessage`関数を呼び出すことができます。

### `extern`の使い方の注意点

1. **同じ名前の変数を複数定義しない**: 異なるファイルで同じ名前のグローバル変数を定義すると、リンク時にエラーが発生します。
2. **ヘッダーファイルでの宣言**: 変数や関数の宣言はヘッダーファイルに書くことが一般的です。これにより、複数のソースファイルで簡単に共有できます。

例として、ヘッダーファイルを使用した方法を見てみましょう。

ヘッダーファイル (`header.h`):

```c
#ifndef HEADER_H
#define HEADER_H

extern int sharedVariable;
void sharedFunction();

#endif /* HEADER_H */
```

ファイル1 (`file1.c`):

```c
#include "header.h"

int sharedVariable = 5;

void sharedFunction() {
    printf("Shared function called.\n");
}
```

ファイル2 (`file2.c`):

```c
#include <stdio.h>
#include "header.h"

int main() {
    printf("sharedVariable = %d\n", sharedVariable);
    sharedFunction();
    return 0;
}
```

### まとめ

- `extern`は変数や関数が別のファイルで定義されていることを示します。
- 変数や関数の宣言と定義を分けることで、異なるファイルからそれらを参照できます。
- ヘッダーファイルに宣言を書くことで、複数のソースファイル間で共有しやすくなります。

このように、`extern`を使うことで、プログラムの異なる部分が同じ変数や関数を効率的に共有できます。

### 参考文献
https://jp-seemore.com/iot/11492/

# ３．関数の宣言と定義
C言語における関数の定義と作成方法について、初心者でも理解できるように詳しく説明します。

### 関数とは

関数は、一連の命令をまとめたもので、特定のタスクを実行するために使用されます。関数を使うことで、コードの再利用性が高まり、プログラムをより構造化しやすくなります。

### 関数の基本構造

関数は以下の部分から構成されます：

1. **関数の戻り値の型**: 関数が返す値の型（例：`int`、`void`など）。
2. **関数名**: 関数を識別するための名前。
3. **パラメータリスト**: 関数に渡される引数のリスト。引数がない場合は空の括弧を使用します。
4. **関数本体**: 中括弧 `{}` で囲まれた関数の処理部分。

### 関数の定義の例

以下に、基本的な関数の定義方法を説明します。

#### 例1: 引数なし、戻り値なしの関数

```c
#include <stdio.h>

// 関数の定義
void sayHello() {
    printf("Hello, World!\n");
}

int main() {
    // 関数の呼び出し
    sayHello();
    return 0;
}
```

この例では、`sayHello`という名前の関数を定義しています。この関数は引数を取らず、`void`型なので戻り値もありません。`main`関数内で`sayHello`関数を呼び出しています。

#### 例2: 引数あり、戻り値ありの関数

```c
#include <stdio.h>

// 関数の定義
int add(int a, int b) {
    return a + b;
}

int main() {
    int sum;
    // 関数の呼び出し
    sum = add(3, 4);
    printf("Sum: %d\n", sum);
    return 0;
}
```

この例では、`add`という名前の関数を定義しています。この関数は2つの整数引数を取り、その和を返します。`main`関数内で`add`関数を呼び出し、結果を表示しています。

### 関数の宣言と定義

大規模なプログラムでは、関数の宣言と定義を分けることが一般的です。関数の宣言は関数のプロトタイプとも呼ばれ、関数の定義を前もってコンパイラに知らせるために使います。

#### 例3: 関数の宣言と定義を分ける

ヘッダーファイル (`myfunctions.h`):

```c
#ifndef MYFUNCTIONS_H
#define MYFUNCTIONS_H

// 関数の宣言（プロトタイプ）
void sayHello();
int add(int a, int b);

#endif /* MYFUNCTIONS_H */
```

ソースファイル (`myfunctions.c`):

```c
#include <stdio.h>
#include "myfunctions.h"

// 関数の定義
void sayHello() {
    printf("Hello, World!\n");
}

int add(int a, int b) {
    return a + b;
}
```

メインファイル (`main.c`):

```c
#include <stdio.h>
#include "myfunctions.h"

int main() {
    sayHello();
    int sum = add(3, 4);
    printf("Sum: %d\n", sum);
    return 0;
}
```

この例では、関数の宣言をヘッダーファイルに記述し、関数の定義をソースファイルに記述しています。`main.c`ではヘッダーファイルをインクルードすることで、関数を使用できるようにしています。

### 関数の作成手順

1. **関数のプロトタイプ（宣言）を記述する**:
   - 必要に応じてヘッダーファイルに記述します。
   - プロトタイプは関数の名前、戻り値の型、引数の型と数を示します。

2. **関数の定義を記述する**:
   - ソースファイルに関数の実際の処理を記述します。
   - 関数本体には実行されるコードが含まれます。

3. **関数を呼び出す**:
   - `main`関数や他の関数から定義した関数を呼び出します。
   - 必要な引数を渡し、戻り値がある場合は受け取ります。

これで、C言語における基本的な関数の定義と作成方法についての理解が深まったと思います。関数を使うことで、コードの再利用性が向上し、プログラムをより効率的に構築できるようになります。
