機能安全規格（ISO 26262やIEC 61508など）に対応したマイコンやSoCでは、ECM（Error Control Module）だけでなく、**ハードウェアおよびソフトウェア双方での安全機能**が複合的に実装されています。以下に代表的な機能をまとめます。

---

## 1. ロックステップコア（Lockstep CPU）

- **概要**  
  - 同一命令列を2つ（あるいは3つ）のCPUコアで並行・同期実行し、リアルタイムで結果を比較。  
  - 演算結果の不一致を検出した場合は故障が生じたと判断し、エラー通知や安全処理（リセット等）を行う。  

- **目的**  
  - CPU内部での演算異常（ALU故障やビット化け）を即座に検出するためのハードウェア冗長化手法。  
  - 自動車のパワートレインや制動制御など、**高ASILレベル（ASIL-Dなど）** で要求されるケースが多い。

---

## 2. メモリ保護機能 (ECC / Parity / MPU)

1. **ECC（Error Correction Code）**  
   - 内蔵Flash/RAMにECCを適用し、**1ビットエラーを訂正・2ビット以上のエラーを検出**できる。  
   - ECMがエラーを検知・訂正し、CPUやソフトウェアへ通知。  
2. **パリティチェック**  
   - RAMやレジスタなどで1ビットのパリティを追加。誤り検出のみ行う簡易手法。  
3. **メモリプロテクションユニット (MPU)**  
   - ソフトウェアが不正アクセスを起こさないよう、**アクセス権**（読み/書き/実行）や**有効アドレス範囲**を設定して保護。  
   - 不正アクセスが発生すると例外を起こして異常を検出・処理する。  

---

## 3. ウォッチドッグタイマ (WDT)

- **概要**  
  - 一定時間内に定期リフレッシュ（クリア）が行われない場合、**タイムアウト** となり**リセット**やエラー通知を出す。  
- **目的**  
  - ソフトウェアのハングアップや無限ループなど、“プログラム暴走”を検出し、自動的にシステムを再起動する。  
  - 「ウィンドウウォッチドッグ」と呼ばれる手法で、**早すぎるクリア** も異常とみなす（過大ループ速度エラー）など、より厳格な監視が可能な製品もある。

---

## 4. BIST（Built-In Self Test）

- **概要**  
  - **起動時**（パワーオンリセット後）や**定期**的に、CPUコアの演算部・内部メモリ・周辺ブロックなどを簡易テストする仕組み。  
  - ハードウェアBISTやソフトウェアライブラリ（セルフテスト）を用いて、演算結果の整合やメモリ書き込み/読み出し異常をチェックする。  
- **目的**  
  - システム起動直後に安全性を担保するための“自己診断”機能。  
  - 規格上、一定のテストカバレッジを満たす必要があるため、BISTを使ってハードウェア故障率を下げる。

---

## 5. クロック・電源電圧監視機能

1. **クロックモニタ (Clock Monitor / PLL Lock Detect)**  
   - 外部/内部オシレータが停止したり、PLLがロックを外れたときに検出する。  
   - 異常なクロック振動はCPU動作を狂わせる要因となるため、検出時はフェイルセーフやリセットをかける。  
2. **電源監視 (Brown-out Detection, Voltage Monitor)**  
   - 供給電圧が許容範囲を下回った場合にリセットや割り込みを発生させる。  
   - 不安定電圧下で動作すると不定動作が起こりやすいので、システムを安全に停止させるための機能。

---

## 6. セーフステートへの移行・フェイルセーフハンドラ

- **概要**  
  - 異常検出時（ECCダブルビットエラー、ロックステップ不一致、WDTタイムアウトなど）、**ソフトウェアやハードウェアが安全状態に移行** するための仕組み。  
  - 安全状態（セーフステート）とは、**出力を停止** したり **安全なデフォルト値** を維持したりする設計で、制御不能・暴走状態を防ぐ。  

- **具体例**  
  - 車載では、危険な動作をさせないために**メインリレーをOFF** にする、あるいは**非常用制御モード**に切り替えるなどのフェイルセーフ処理を行う。

---

## 7. 安全管理コントローラ / 安全ドメイン (Safety Island)

- **概要**  
  - 一部のSoCでは、メインCPUとは独立した**セーフティコア**や**安全管理コントローラ**を搭載し、ECMやWDT、BIST、エラーログなどを一元管理。  
  - 異常発生時にメインCPUやシステムへ迅速かつ確実に通知し、**安全制御** を行う。  

- **目的**  
  - メインCPU自体がハングアップしても、**独立安全コントローラ**が動作していればリセット・通報・安全モード移行を指示できる。  
  - システム全体の信頼度（ASILレベルなど）を高めるために重要。

---

## 8. セルフテストライブラリ (Software Test Library)

- **概要**  
  - メーカー提供またはサードパーティ製のソフトウェアライブラリで、**CPU演算テスト**、**メモリテスト**、**周辺テスト** などを一通り実行するAPIがまとめられている。  
  - 関数を呼び出すと内部でテストパターンを実行し、結果をレジスタなどで判定する仕組み。  

- **目的**  
  - 安全規格で求められるテストを“**開発者が容易に組み込める**”ようにし、**認証取得** も簡素化する。  
  - ハードウェアBISTと組み合わせて、**起動時** と **定期的な自己診断** の両面をカバーする。

---

## 9. 高耐ノイズ設計、パッケージ/レイアウト上の工夫

- **EMC/EMI耐性**  
  - 機能安全用途では、ノイズによる誤動作を防ぐために**パッケージ設計**や**内部配線**に注意が払われている。  
- **チップレベルの冗長性**  
  - パッド短絡検出、I/Oポートの過電流保護など、ハード不良が発生しても破壊を最小限に抑える仕組みが用意されている場合がある。

---

## まとめ

- **機能安全対応マイコン** には、単にECM（Error Control Module）だけでなく、**CPUロックステップ、ECC、WDT、BIST、MPU、電源監視、クロック監視、フェイルセーフ制御** といった様々な安全機能が組み込まれています。  
- これらを総合的に連携させることで、**ソフトエラー・ハード故障を速やかに検知** し、システムを安全側へ移行させることが可能になっています。  
- メーカー製のセルフテストライブラリや安全管理コントローラも併せて活用することで、**ISO 26262/IEC 61508 などの機能安全規格** を満たす設計がしやすくなるのが特徴です。

機能安全対応マイコンが「ECC」「WDT」「ロックステップ」など複数の安全機能を持つ場合でも、実際には**どのタイミングで何が動いて、どのように連携するのか**が分かりづらいですよね。  
ここでは、**典型的なエラー発生例**に沿って、各機能がどんな**時系列**で動くかをイメージしやすいように説明します。

---

# 1. ECCでエラー検知～リセットの典型的な流れ

まず、**メモリ読込み時にECCエラー**が発生した場合を考えます。ECCは1ビットエラーなら即座に訂正でき、2ビット以上のエラーは「訂正不能エラー」として検出します。  
以下に、ECC検知によるエラーハンドリングの**一例**を示します。

```
        ┌─────────────────────────────────────────────────┐
(1) CPUがROM/RAMを読み出す
        │  ↓(内部でECCが検証)
        │
(2) ECCモジュールがエラーを検出
        │  └─ シングルビット誤り → 自動訂正・ステータス更新のみ
        │       ダブルビット誤り → "訂正不能"フラグ立てる
        │
(3) ECCモジュールがエラー割り込み (NMIなど高優先度例外) をCPUへ通知
        │
(4) CPUがエラーハンドラを実行
        │  └─ エラーログ取得
        │     セーフティ機能へ通知
        │     → (必要に応じて) ソフトウェア側でリカバリ試行 or フェイルセーフ移行
        │
(5) ソフトウェアで「再起動」が必要と判断
        │  └─ 例）「ECCエラーが致命的」と判断 → ソフトウェアリセット or WDT意図的タイムアウト
        │
(6) マイコンリセット発生
        │  └─ CPU/各レジスタ初期化、再起動シーケンスへ
        └─────────────────────────────────────────────────┘
```

- **(2)でのECC検出**: 1ビットエラーならマイコン内部で自動訂正が行われ、通常動作を続けるケースが多いです。  
- **(3)(4)での割り込み通知**: 2ビット以上のエラーなど「訂正不能」な場合はエラーフラグを立て、通常はNMIや専用の安全割り込みでCPUへ即通知します。  
- **(5) ソフトウェアが判断**: エラーハンドラでは、「再読み込みする」「バックアップから復元する」「ソフトリセットをかける」等を行います。場合によっては、WDTをクリアせずタイムアウトさせ、ハードウェアリセットさせる手段をとることもあります。  

---

# 2. WDTでのリセット～再起動の典型的な流れ

次に、**ソフトウェアのハングアップや処理フロー異常**を検出するためのWDTの連携例を考えます。

```
        ┌─────────────────────────────────────────────────┐
(1) 通常動作時
        │  └─ メインループ等で周期的にWDTをリフレッシュ
        │
(2) 何らかの不具合発生
        │  └─ 例）無限ループ／デッドロックに陥り
        │           WDTリフレッシュが止まる
        │
(3) WDTがタイムアウト
        │  └─ WDTハードウェアがマイコンへリセット信号発行
        │
(4) マイコンリセット
        │  └─ 再起動シーケンス (電源オン時と同じ初期化動作)
        └─────────────────────────────────────────────────┘
```

- **(1) 通常動作**: 定期的に`WDT_Clear()`などを実行し、タイムアウトを回避。  
- **(2) ハングアップ**: 予期せぬ無限ループやメモリ破壊で通常フローが実行されず、WDTクリアが行われなくなる。  
- **(3)(4) タイムアウト＆リセット**: 再起動でシステムを復旧。その際に「異常履歴レジスタ」をチェックして原因調査・ログ保存などをする。  

---

# 3. ロックステップ不一致～安全動作への流れ

ロックステップCPUの場合、**演算結果に不一致**（片方のCPUだけビット化け等）が起きた瞬間にエラーを検知します。

```
        ┌─────────────────────────────────────────────────┐
(1) 2つのコア(CPU0, CPU1)が同一命令を同期実行
        │
(2) ロックステップ比較器が両コアの結果を常時比較
        │  └─ CPU0の演算結果 ≠ CPU1の演算結果 → 不一致検出
        │
(3) 不一致検出信号をエラーマネジメントへ通知
        │  └─ ECM (Error Control Module)や安全コントローラが割り込み/例外発生
        │
(4) エラーハンドラ or 安全コントローラがセーフティ動作
        │  └─ 重大度に応じて:
        │     - ソフトウェアリセット/ハードリセット
        │     - フェイルセーフモードへ移行 (安全機能のみ動作)
        └─────────────────────────────────────────────────┘
```

---

# 4. 多機能が連携する実運用シナリオ例

上記は個々の機能の流れですが、実際にはそれぞれが**同時に有効**になっており、トリガとなるイベントによって**異なるルート**でエラーがハンドリングされるのが普通です。  
代表的なシナリオを2つ示します。

## シナリオA: ECCダブルビットエラーの発生

1. **CPUがプログラムメモリを読み出し** → ECC制御が**2ビットエラー**を検出  
2. **ECM（Error Control Module）がNMI**や専用割り込みをCPUへ通知  
3. **エラーハンドラ内**でエラーログを取得 ⇒ 「訂正不能エラーにつき再起動」と判断  
4. **ソフトウェアがWDTリフレッシュを止める** か、**ソフトウェアリセット命令**でリセット  
5. **マイコンリセット** → 初期化 → 再起動  

このとき、もしハンドラが**何らかの理由でハングアップ**すれば、**WDT**がタイムアウトを起こし結果的にリセットを掛けるため、**二重三重に対策**が講じられています。

## シナリオB: ソフトウェアの暴走（ハングアップ）

1. ある時点でバグ等が原因で、**メインループが無限ループ**に陥る  
2. **WDTリフレッシュ**が行われず、**WDTタイムアウト**  
3. **マイコンリセット** → 再起動  
4. 起動時に**BIST**や**エラーログ**を確認し、原因調査・フェイルセーフモードで立ち上げる…など。  

このシナリオでは、**ECCエラー検出は特に動作しない**ですが、ロックステップCPUが演算不一致を見つけたら同様に**安全停止**になり得る、という風に各機能が独立した監視ポイントを担当しています。

---

# 5. 各機能のつながり・総合イメージ

典型的な機能安全マイコンの監視ループやハンドリングを**簡易フローチャート**でまとめると、次のようなイメージになります。

```
                   [ 電源投入 / リセット ]
                           │
                           ▼
                ┌───────────────┐
                │ BIST / セルフテスト  │  ← 起動時メモリテスト、CPU演算テストなど
                └───────────────┘
                           │ OK?
                           │ ┌─── NO → フェイルセーフ or リセット再試行
                           ▼
                ┌─────────────────┐
                │ 通常動作 (Main) │
                └─────────────────┘
                 │  |    |   |
                 │  |    |   └─[ECC] … メモリアクセス毎に自動チェック
                 │  |    └─────[ロックステップ比較器] … CPU演算結果を常時比較
                 │  └────────────[MPU/保護機能] … 不正アクセスを例外捕捉
                 │
                 ▼ (定期)
         [ソフトが WDTリフレッシュ]
                 │
                 │  ┌────────────────────────────┐
                 │  │(もしハング/暴走すればWDTがタイムアウト)│
                 │  └────────────────────────────┘
                 │
  ┌─ ECCエラー検知 (ダブルビット)  → Error IRQ → エラーハンドラ → リセット or フェイルセーフ
  │
  └─ ロックステップ不一致         → 安全モジュール → リセット or フェイルセーフ
```

こうして見ると、**どのフェーズ（起動時/通常動作/エラー検出時）にも複数の機能が絡み合っており**、それぞれ独立にエラーを検出すると**最終的には「安全側へ倒す」**という動作が共通していると分かります。

---

## まとめ

1. **ECC** はメモリ読み出し時に誤りを即検出し、単ビットなら自動訂正、複数ビットならエラーフラグを挙げてCPU通知 → **ソフトが必要に応じてリセット** などを行う。  
2. **WDT** はソフトウェア側がハングしたとき自動でリセットをかける仕組み。エラー検出ルートの最後の「守護者」として機能することが多い。  
3. **ロックステップ** はCPU内の演算結果不一致をリアルタイムで検知し、すぐに安全モジュールがエラーを宣言 → **システムを安全側**（リセットorフェイルセーフ）へ移行する。  
4. 実際のマイコンではこれらが**同時並行**で走っており、**どこで異常が検出されても最終的には安全制御が働く**よう、多重化された設計になっている。

こうした流れを押さえておくと、マイコン異常時に「どの機構が先に働き、どういう経路でリセットやフェイルセーフに至るのか」がイメージしやすくなるはずです。  


```
                   [ 電源投入 / リセット ]
                           │
                           ▼
                ┌───────────────┐
                │ BIST / セルフテスト  │  ← 起動時メモリテスト、CPU演算テストなど
                └───────────────┘
                           │ OK?
                           │ ┌─── NO → フェイルセーフ or リセット再試行
                           ▼
                ┌─────────────────┐
                │ 通常動作 (Main) │
                └─────────────────┘
                 │  |    |   |
                 │  |    |   └─[ECC] … メモリアクセス毎に自動チェック
                 │  |    └─────[ロックステップ比較器] … CPU演算結果を常時比較
                 │  └────────────[MPU/保護機能] … 不正アクセスを例外捕捉
                 │
                 ▼ (定期)
         [ソフトが WDTリフレッシュ]
                 │
                 │  ┌────────────────────────────┐
                 │  │(もしハング/暴走すればWDTがタイムアウト)│
                 │  └────────────────────────────┘
                 │
  ┌─ ECCエラー検知 (ダブルビット)  → Error IRQ → エラーハンドラ → リセット or フェイルセーフ
  │
  └─ ロックステップ不一致         → 安全モジュール → リセット or フェイルセーフ

```

```
┌───────────────────────────────────────────────┐
│                [ CPU (Lockstep) ]           │
│  ┌─────────────────────┐   ┌─────────────────────┐
│  │ CORE0 (Main)        │   │ CORE1 (Mirror)      │
│  │ (実行命令は同じ)    │   │ (演算結果を比較)    │
│  └─────────┬───────────┘   └─────────┬───────────┘
│            │  同期実行                │ 同期実行
│            ▼                           ▼
│         ┌───────────────────────────────────────┐
│         │ Lockstep Comparator                  │
│         │  → コア間演算結果に不一致あればエラー通知 │
│         └───────────────────────────────────────┘
└───────────────────────────────────────────────┘
                           │
                           │ 不一致/エラー時
                           ▼
  ┌─────────────────────────────────────────┐
  │         [ ECM (Error Control Module) ] │
  │  - ECCエラー, ロックステップ不一致,  │
  │    バスエラー等を集約管理            │
  │  - エラーログ取得 & CPU/Safetyへ通知 │
  │  - 場合によってはリセット制御        │
  └─────────────────────────────────────────┘
         ▲                   ▲
         │                   │ エラー情報 (割り込み/NMIなど)
         │                   └───────────┐
         │                               │
         │                               │
         ▼                               │
┌───────────────────────────┐            │
│       [ Flash ROM ]       │            │
│    + ECCハードウェア       │            │
│    (SEC-DEDなど)           │            │
│  1ビットなら自動訂正       │            │
│  2ビット以上はエラー検出   │            │
└───────────────────────────┘            │
         ▲                               │
         │ 読み出し                       │
         │ ECCエラー                      │
         ▼                               │
┌───────────────────────────┐            │
│       [ SRAM ]            │            │
│    + ECCハードウェア       │            │
│    (SEC-DEDなど)           │            │
└───────────────────────────┘            │
                                          │
                                          │
                 ┌────────────────────────┴────────────────────────┐
                 │              [ WDT (Watchdog Timer) ]          │
                 │ - ソフトが定期的にリフレッシュしない場合       │
                 │   タイムアウトしてリセット発動                 │
                 │ - ハングアップを自動検出→システム再起動        │
                 └─────────────────────────────────────────────────┘
                                          │
                                          │ リセット信号
                                          ▼
                  ┌───────────────────────────────────────────┐
                  │    [ Safety / System Reset Logic ]       │
                  │  - ECMやWDTからの要求があればシステム     │
                  │    をリセットし初期化                    │
                  │  - 起動後にBISTやエラーログ確認等を実施   │
                  └───────────────────────────────────────────┘

```

```
  ┌───────────────────────────[ External Bus or SoC I/F ]──────────────────────────┐
  │                                                                                 │
  │   (他のECU/Peripherals)                                                        │
  │                                                                                 │
  └───────────────────────────────────────────────────────────────────────────────────┘


                         ┌────────────────────────────────────┐
   ┌─────────────────────┤          [ CPU Subsystem ]        ├─────────────────────┐
   │                     └────────────────────────────────────┘                     │
   │                                (Lockstep構成の例)                              │
   │      ┌───────────────────────────┐        ┌───────────────────────────┐        │
   │      │  CORE0 (Main Execution)   │        │ CORE1 (Lockstep Mirror)   │        │
   │      │-命令フェッチ/実行         │        │-同じ命令を同期実行        │        │
   │      │-レジスタセット, ALU       │        │-演算結果を比較器へ送出     │        │
   │      └─────────────┬─────────────┘        └─────────────┬─────────────┘        │
   │                    │ (同一バスアクセス/命令実行)         │                             │
   │                    ▼                                     ▼                             │
   │      ┌──────────────────────────────────────────────────────────────┐                    │
   │      │       Lockstep Comparator (LSC)                             │                    │
   │      │  ・CORE0/CORE1の演算結果・主要レジスタ更新をリアルタイム比較 │                    │
   │      │  ・不一致の場合は "Lockstep Error" を検出 → 例: NMI信号等     │                    │
   │      └──────────────────────────────────────────────────────────────┘                    │
   │                    │                                                                   │
   │                    │ Lockstep Error発生(不一致)                                        │
   │                    │ → 信号ライン (ls_error)                                          │
   │                    ▼                                                                   │
   │      ┌──────────────────────────────────────────────────────────────┐                    │
   │      │   CPU Internal Bus / AXI/AHB Bridge etc.                    │                    │
   │      └──────────────────────────────────────────────────────────────┘                    │
   │                                    │
   │                                    │ CPU命令/データアクセス
   │                                    │
   │                                    ▼
   └───────────────────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        │  (バス経由でFlash/RAMへアクセス)
                                        ▼

┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                          [ Memory Subsystem ]                                            │
│                                                                                           │
│   ┌─────────────────────────────────────────────────────────────────────────────────────┐   │
│   │ [ Flash ROM + ECC Logic ]                                                          │   │
│   │   ┌───────────────────────┐      ┌───────────────────────────────────────────────┐ │   │
│   │   │   Flash Array (Code)  │ ---->│   ECC Decoder/Encoder (SEC-DED etc.)         │ │   │
│   │   └───────────────────────┘      └───────────────────────────────────────────────┘ │   │
│   │      │  1) CPUがコード/定数を読み出す                                               │   │
│   │      │     → ECCロジックがビット誤りチェック                                        │   │
│   │      │  2) 1bit誤り → 自動訂正してデータ返却                                        │   │
│   │      │     2bit以上 → "Uncorrectable Error" フラグ                                 │   │
│   │      └───────────────────────────────────────────────────────────────────────────┘   │
│   │                                                                                       │
│   └─────────────────────────────────────────────────────────────────────────────────────┘   │
│                 ▲
│                 │ (同様に、RAMもECC付きの場合の例)
│   ┌─────────────────────────────────────────────────────────────────────────────────────┐   │
│   │ [ SRAM + ECC Logic ]                                                               │   │
│   │   ┌───────────────────────┐      ┌───────────────────────────────────────────────┐ │   │
│   │   │   SRAM Array (Data)   │ ---->│   ECC Decoder/Encoder (SEC-DED etc.)         │ │   │
│   │   └───────────────────────┘      └───────────────────────────────────────────────┘ │   │
│   │      │  1) CPU/DMACなどがデータR/W                                                 │   │
│   │      │     → ECCロジックがビット誤りチェック                                        │   │
│   │      │  2) 1bit誤り → 自動訂正 & ステータス記録                                     │   │
│   │      │     2bit以上 → "Uncorrectable Error" フラグ                                 │   │
│   │      └───────────────────────────────────────────────────────────────────────────┘   │
│                                                                                           │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        │ECCエラー検出時 (Single/Doubleビット)
                                        │
                                 ┌──────▼─────────────────────┐
                                 │ [ ECM (Error Control Module)]│
                                 │   - ECCからのErrフラグ受信   │
                                 │   - Lockstepエラー受信       │
                                 │   - バスエラーなども集約     │
                                 └─────────────┬────────────────┘
                                               │
                  ┌─────────────────────────────┼──────────────────────────────────┐
                  │                             │ Error発生時                    │
                  ▼                             │                                ▼
    ┌────────────────────────┐                  │              ┌─────────────────────────────────┐
    │ [ Interrupt Controller ]<----------------─┘              │ [ Safety / Reset Controller ]  │
    │  - 割り込み/NMI管理                         LockstepErr   │  - ECMやWDTリセット要求を受け   │
    │  - ECMが割り込み要求を出す   ECC(2bitErr)  → intLine   →  │    システムリセット発生         │
    └────────────────────────┘    or other → nmiLine         │  - リセット後の復旧シーケンス     │
                                                          └─────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                      [ WDT (Watchdog Timer) ]                                             │
│  ┌───────────────────────────────────────────────────────────────────────────────────────┐ │
│  │  - ソフトが規定周期でWDTリフレッシュ (WDT_Clear()等)                               │ │
│  │  - リフレッシュ滞る(ハングアップなど) → タイムアウト → ハードウェアリセット     │ │
│  │  - Window WDTの場合、早すぎるクリアも誤動作として検知                           │ │
│  └───────────────────────────────────────────────────────────────────────────────────────┘ │
│          │                                                                           │
│          │ Timeout発生時                                                             │
│          ▼                                                                           │
│    ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│    │   [ Safety / Reset Controller ]                                              │ │
│    │    - WDTリセット要求を受信                                                   │ │
│    │    - マイコン全体にリセット信号                                              │ │
│    └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────────────┘

```

以下ではご質問に沿って、それぞれの内容を解説します。

---

## ① ECCの動作原理と、ビット化けを検知・修正できる手法はECCだけか？

### ECC (Error Correction Code) の動作原理

- **概念**  
  ECC はメモリ上のデータに対して冗長ビット（パリティ情報）を付加し、読み出し時に冗長ビットを用いてエラー（ビットの誤り）を検出・訂正できるようにした仕組みです。  
  代表的なものに **Hamming符号** や **SEC-DED (Single Error Correction - Double Error Detection)** などがあります。

- **基本的なしくみ**  
  1. **書き込み時**:  
     書き込むデータ(たとえば 64ビット)から計算されるECCビット(数ビット程度)を一緒にメモリへ格納します。  
  2. **読み出し時**:  
     データ(64ビット)とECCビット(付加情報)を同時に読み出し、専用のデコーダで整合性をチェックします。  
     - 1ビットの誤りならば位置が特定され、自動的に訂正（Correction）されます。  
     - 2ビット以上の誤りの場合は訂正不可能ですが、少なくとも「エラーが起こっている」ことを検知（Detection）できます。

- **メリット・デメリット**  
  - **メリット**:  
    - 1ビット誤りを訂正できるため、ソフトエラー(宇宙線や放射線によるビット反転など)への耐性が高い。  
  - **デメリット**:  
    - 冗長ビット分のメモリ領域が増える。  
    - デコードやエンコードに若干のハードウェア・時間的オーバーヘッドがある。  

### ビット化けの検知・修正は ECC だけか？

- **ECC以外にもある主な手法**  
  1. **二重化・三重化 (TMR: Triple Modular Redundancy)**  
     重要なメモリやレジスタを複数用意し、同一データを保管・比較することで誤りを検知・訂正する手法。ハードウェア実装が大掛かりになる反面、信頼性は高い。  
  2. **ソフトウェアCRC/ハッシュによる冗長チェック**  
     重要データにCRCやハッシュを付加しておき、定期的に読み出し検証する。1ビット誤りを検知できるが、そのままでは「自動訂正」は難しい。訂正が必要な場合は、複数バックアップ(冗長保存)と組み合わせる。  
  3. **リードバック検証 (Write-Read-Verify)**  
     メモリ書き込み直後に読み出してチェックし、誤りがあれば再書き込みを試みるといった手法。これも検知に重きを置いており、リアルタイム訂正は難しい。  

- **結論**  
  - 1ビットのビット化けを自動的に「検知して即座に修正」する機能をハードウェアレベルで提供するのは **ECC** が代表的です。  
  - ただし、冗長化やソフトウェア再読み出し・バックアップからの復旧などにより、ECC以外でも「結果的に修正」できる手段は存在します。  
  - しかしリアルタイム・オンザフライで修正まで行う点でECCが最も一般的かつ効率的です。

---

## ② ROM/RAM異常でマイコンリセットすることはあるか？マイコンリセットの原理

### ROM/RAM異常でマイコンがリセットする例

- **想定されるケース**  
  1. **起動時（ブート時）のチェック失敗**:  
     電源投入やリセット後にブートローダーがROM(フラッシュ)やRAMの整合性をチェックし、異常があれば再起動やフェイルセーフ処理を行う。  
  2. **定期メモリテストでの致命的な異常検出**:  
     ソフトウェアまたはハードウェアBIST等でRAM/ROMテストをし、エラーが修正不能（ECCで直せない、あるいはテスト結果が不合格など）と判断した場合にシステムがリセット要求を出す。  
  3. **動作中のプログラム破損検知**:  
     実行コード領域（ROM）に対しCRCチェックを行い、破損と判断されるとソフトウェア的にリセットをかける・ウォッチドッグを意図的に使って再起動するなどの対策をとる。

### マイコンリセットの原理

- **基本的なしくみ**  
  - マイコン内部には “リセット回路” が存在し、リセット信号がアサート（LowアクティブやHighアクティブなどマイコンにより異なる）されると、CPUコアや内部周辺回路は初期化された状態に戻り、**PC（プログラムカウンタ）** をブートローダーやリセットベクタが指すアドレスへ飛ばして、再度プログラムを開始する。  
  - リセットには以下のような種類がある。  
    1. **パワーオンリセット (POR)**: 電源投入時の自動的リセット。  
    2. **エクスターナルリセット (外部ピン接続)**: 外部リセット入力を引くことで強制的にリセット。  
    3. **ウォッチドッグリセット**: WDTがタイムアウトしたときに発生。  
    4. **ソフトウェアリセット**: ソフトウェア命令でリセット制御レジスタを書き込んで発生。  
    5. **ブラウンアウトリセット**: 電源電圧が閾値以下になった際にマイコンが不安定にならないようリセットする。  

---

## ③ WDT(ウォッチドッグタイマ)の原理と用途

### WDTの原理

- **基本的なしくみ**  
  - WDTは一定周期でカウントアップ（またはダウン）するハードウェアタイマです。  
  - 正常に動作しているソフトウェアは定期的に「ウォッチドッグのカウンタリセット」や「クリア」動作を行い、タイムアウトしないようにします。  
  - **ソフトウェアがハングアップ**（無限ループ・デッドロック）してWDTをクリアできなくなると、WDTが **タイムアウト** を検出してリセット信号を発生し、マイコンを再起動させます。  

- **目的**  
  - メインループやタスクスケジューラが正常に回っているかを “定期的にソフトウェア自身でチェック” させるための安全機構。  
  - システムが暴走した際に自動復旧を図る。  

### WDTの用途

1. **システム暴走検出**  
   - プログラムカウンタが想定外の場所を実行し始める/無限ループなどで止まる → WDTタイムアウト → リセット・再起動。  
2. **リアルタイム性向上**  
   - タイマ割り込みやメインタスクが一定期間ごとにWDTをクリアすることで、「ソフトウェアが最低でもこの周期では動作している」ことの保証に使う。  
3. **フェイルセーフ**  
   - 不測の異常時にもシステムをリセットし安全状態に戻すために活用。  

---

## ④ マイコン演算異常の検知とロックステップ方式の活用、動作原理

### ロックステップ方式は活用されるか？

- **高信頼性・機能安全用途では活用される**  
  - 自動車のパワートレイン制御、産業用安全システム、航空宇宙向けなど、**故障を極限まで低減しなければならない分野**で、**マイコン内部コアをロックステップ構成**にしている製品があります。  
  - 例えば車載用マイコン(Renesas RH850ファミリの一部、Infineon AURIXなど)では **デュアルコア ロックステップ** や **TriCoreロックステップ** と呼ばれる実装が存在します。

### ロックステップ方式の動作原理

- **基本概念**  
  - **2つ以上のCPUコア** が同じクロックで **同じ命令列を同期的に実行** し、各ステージの出力（演算結果やレジスタ更新）を常時比較します。  
  - 比較器(Comparator)でリアルタイムに両コアの演算結果を突き合わせ、**少しでも差異があれば異常**（演算ミス・ビット化け等）と判断し、エラー信号を生成します。

- **動作イメージ**  
  1. **命令フェッチ〜実行** までを、コア1とコア2が全く同じタイミングで行う。  
  2. **演算結果や主要レジスタ** の値を周期的または毎サイクル比較する。  
  3. **不一致発生** → いずれかのコアに発生した故障・ビット化けとみなしてエラーを通知。  
  4. システムはエラー通知を受けると、**安全側へ移行**（リセットやフェイルセーフ）する。  

- **メリット**  
  - シングルコアと比較して演算異常を高い精度で検知できる。  
  - 1サイクルの遅延を設けた “Delayed Lockstep” など複数のバリエーションがあり、配線遅延やタイミングばらつきによる誤検知を防ぐ工夫をすることもある。

- **デメリット**  
  - ハードウェア資源や消費電力が増える。  
  - ソフトウェア的に2コアを独立利用できない（あくまで同じコードを動かすため、性能が2倍になるわけではない）。  

### マイコン演算異常検知における他の例

- **2回演算して結果を比較**:  
  ソフトウェア的に同じ計算を2度行い、結果が一致しなければ異常とする簡易手法。ロックステップと比べるとリアルタイム性・確実性で劣るが、ハードウェア変更不要で実装可能。  
- **CPU Built-In Self Test (BIST)**:  
  起動時や周期的にALU/レジスタ/バスなどに対して簡易演算テストを実行し、結果の一致をチェックする。リアルタイム検知というより定期的な健全性確認。  

---

## まとめ

1. **ECC (Error Correction Code)**  
   - メモリ上のビット誤りを **検知・訂正** する代表的なハードウェア機構。  
   - リアルタイムで訂正できる点が強みだが、冗長ビットを持つなどのコストがある。  
   - ECC以外にも、二重化・三重化やソフトウェア検証手法などでビット化けの検出・訂正を実現するアプローチは存在。

2. **ROM/RAM異常でのマイコンリセット**  
   - ブート時や定期テストで致命的異常を発見した際にソフトウェアがリセット要求をかけたり、ハードウェア保護機能がリセットを発生させることはある。  
   - リセットはマイコン内の回路が全レジスタなどを初期化し、再起動を行う仕組み。

3. **ウォッチドッグタイマ(WDT)**  
   - 一定周期でリフレッシュされなければタイムアウトし、マイコンにリセットをかける安全装置。  
   - ソフトウェア暴走・ハングアップを自動検出し、再起動させる用途に使われる。

4. **演算異常検知とロックステップ方式**  
   - 演算異常検出において **ロックステップ** は高い信頼性を得るための代表的手法。  
   - 同一命令列を2つ以上のコアで同期実行し、その結果を常時比較することでビット化けやALU故障を即座に検出。  
   - 車載・産業などの機能安全分野で広く採用されている。  

以上になります。マイコンの高い信頼性や安全性を確保するには、ECCやロックステップなどのハードウェア機能と、ウォッチドッグや定期的メモリ/演算テストなどのソフトウェア機能を組み合わせることが一般的です。

以下、それぞれのご質問に対する回答です。

---

# ① CRCチェックとは？  
また、WDTでどのように再起動するのか？

## 1. CRC（Cyclic Redundancy Check）とは

- **CRCチェック** は、主にデータの破損や誤りを検出するための **エラーチェック手法** です。  
- 具体的には、**多項式演算**（ビット演算）を用いてデータから「CRC値（余り）」を計算し、その値を保存しておきます。  
- 後でデータを取り出したときに再度同じようにCRC値を計算して、保存してあるCRC値と比較します。  
- 一致しなければデータが途中で化けた（誤りが含まれた）と判断できます。

### 例：ROMのCRCチェック

- **ROMに書き込まれたプログラムコード** や **定数データ** などが破損していないかを調べるために、あらかじめROM全体や一部領域に対してCRC計算した値を保管しておきます。  
- 起動時や定期的に同じアルゴリズムでCRCを再計算し、保管しておいたCRC値と一致するかを確認します。  
- 一致しない場合は、「ROMが破損した（ビット化け、書き込みミス等）」とみなし、異常対応（エラー表示や再起動など）を行うことができます。

## 2. WDT（ウォッチドッグタイマ）での再起動

- **WDT（ウォッチドッグタイマ）** とは、一定時間内にソフトウェアが「ウォッチドッグのクリア（リフレッシュ）」をしないと、**タイムアウト** としてマイコンに **リセット信号** を送るハードウェア機構です。
  
- **ソフトウェア的にリセットをかける方法**  
  - CRCチェックなどの結果、プログラムが破損していると判断したら、**あえてウォッチドッグをクリアしない** ようにし、WDTがタイムアウトを起こすようにします。  
    - WDTがタイムアウト → **マイコンがリセット** されて再起動。  
  - あるいは、マイコンによっては **WDTを強制的に動作させる** あるいは **ソフトウェアリセット命令**（リセット制御レジスタを書くなど）を使って直接リセットをかける場合もあります。  

> **要点**: “WDTは通常は暴走検出用” ですが、あえてソフトウェアで「意図的に」リフレッシュを止めることで、**正常にマイコンをリセット** する用途にも使えます。

---

# ② ソフトウェアのハングアップとは？

- **ソフトウェアのハングアップ** は、プログラムが何らかの理由で **停止** または **意図しない無限ループ** に陥り、**本来の処理を続行できなくなる** 状態のことをいいます。  

## 具体的な例

1. **無限ループ**  
   - バグなどでループを抜け出す条件が満たされない、または条件が永久に偽にならないなど。  
   - CPUはずっと同じコードを実行し続け、他の処理が行えない。

2. **デッドロック（排他ロックの取り合い）**  
   - マルチタスク・マルチスレッド環境で、複数のタスクが互いにロックを待ち続けて永久に進まない状態。  

3. **割り込み応答が無限にかかり続ける**  
   - 割り込みハンドラから抜けられない設計ミスで、メイン処理に戻れない。

4. **スタック破壊やメモリ破壊による異常ジャンプ**  
   - 不正アドレスにジャンプしてしまい、正常な命令実行ができずに暴走または停止状態。

いずれの場合も **WDT** や **例外処理** などを使って検出しない限り、ソフトウェアが回復できないことが多いため、**ハングアップ** は致命的な障害になります。

---

# ③ 機能安全用途でのマイコン異常対策手法

自動車などの機能安全規格（ISO 26262など）に対応が求められる分野では、下記のような **ハードウェア機能** や **ソフトウェア手法** が組み合わされます。

## 1. ROM/RAM化け（ビット反転、書き換わり）への対策

- **ECC（Error Correction Code）**  
  - メモリ(ROM/RAM)をECC付きで実装し、1ビットエラーは自動修正、2ビット以上はエラー検出する。  
- **CRC/チェックサム**  
  - フラッシュROM内のプログラムや設定領域に対してCRCなどを計算・比較することで化けを検出。  
  - 破損検知時は安全側へ移行（再起動、フェイルセーフ動作など）。  

## 2. ROM/RAM異常（セル故障、読み書き不能など）への対策

- **BIST (Built-In Self Test)／メモリテスト**  
  - 起動時や定期的にハードウェア・ソフトウェア実装のメモリテストで異常セルをチェック。  
- **ECC / パリティチェック**  
  - 同上。1ビット誤りなら訂正できるECCなどが用いられる。

## 3. 処理順序異常（プログラムフロー異常）への対策

- **ウォッチドッグタイマ(WDT)**  
  - ソフトウェアが一定周期で正常実行しているかを監視。不具合でフローが止まればリセット。  
- **フローチェック機構 / MPU (Memory Protection Unit)**  
  - 重要関数の入り口・出口に特定のチェックやカウンタ更新を入れ、順序が狂ったらエラーとする。  
  - メモリ保護機能で不正アドレスアクセスを例外検出し、安全停止させる。

## 4. 演算異常（ALU故障など）への対策

- **ロックステップ方式**  
  - 同一命令を2つ以上のCPUコアで並行実行し、リアルタイムで結果を比較。不一致なら即エラー処理。  
- **CPUセルフテスト / 二重化計算**  
  - 起動時に短いアルゴリズムテストでCPU演算が正常かチェックする。  
  - 重要な演算はソフト的に2回/3回行い、結果比較で異常を検出する。

---

# まとめ

1. **CRCチェック** は多項式演算によりデータ破損を検知する手法。ROM上のプログラムやデータが書き換わっていないかを簡易的かつ高精度にチェックできる。  
2. **WDTで再起動** する場合は、ソフトが意図的にWDTのクリアを行わずタイムアウトさせたり、WDT制御レジスタを使ってリセットを発生させる。  
3. **ソフトウェアのハングアップ** とは、無限ループやデッドロックなどによってプログラムが停止・暴走状態に陥り、正常処理が進行しなくなる現象。  
4. **機能安全用途** では、  
   - ROM/RAM化け・異常：ECC、CRC、BISTなど  
   - 処理順序異常：WDT、フローチェック機構  
   - 演算異常：ロックステップ方式やCPUセルフテスト  
   を組み合わせ、高信頼性・安全性を実現している。

以上がご質問に対する回答となります。  

「ECM (Error Control Module)」は、マイコンやSoC内部で**各種エラー（主にメモリエラーやバスエラーなど）を監視・制御するためのハードウェアブロック**のことを指す場合が多いです。  
ただし、ECMという名称は**メーカーや製品系列によって指す内容が異なる**可能性があります。たとえば、

- **Error Correction Module** の略として、メモリのECC（Error Correction Code）処理を行うハードウェア  
- **Error Control Module** として、メモリだけでなくバスエラーや周辺モジュールの異常を検出し、割り込みや例外処理、エラーログ取得などを行う制御ブロック  
- 内部で検出した各種エラー情報（例：シングルビットエラー、ダブルビットエラー、アクセス違反）を一元管理してCPUコアや安全機構（Safety Management Unit など）へ通知するユニット  

といった具合に、**「エラーを検出・管理し、必要に応じて訂正あるいは通報する」** ことを主な役割としていることが多いです。

---

## 一般的なECMの主な機能例

1. **ECCエンコード／デコード**  
   - メモリ（RAM/フラッシュ）への書き込み時・読み出し時にECCの生成・検証を行い、  
     - **1ビット誤りを自動訂正** (Single Error Correction)  
     - **2ビット以上の誤りを検出** (Double Error Detection)  
   - 訂正不可能なエラーが発生したらECMがエラーフラグを立てる。

2. **バスエラーや保護違反の検出**  
   - 不正なアドレスアクセス、許可されていない操作などが行われた場合に異常を捕捉し、割り込みや例外を発生させる。  

3. **エラー情報の記録・レジスタ保持**  
   - どのアドレスでエラーが起こったか、エラーの種類は何か（シングルビット or ダブルビットなど）をログとしてレジスタに保持し、ソフトウェアから参照できるようにする。

4. **エラー通知・割り込み生成**  
   - 訂正不可エラー（Double Bit Errorなど）が起きた場合や特定の条件で、CPUコアや安全機構、システムハンドラへ通知を出し、フェイルセーフ動作・リセットなどの後処理を実行させる。

5. **テストや自己診断用の仕組み**  
   - 機能安全向けマイコンであれば、エラー注入（Error Injection）や自己診断（BIST）と連動し、ECM側で強制的にエラーを発生させるテストモードを備えている場合もある。

---

## ECMが使われる文脈

- **車載マイコン** (例: Infineon AURIX, Renesas RH850, NXP S32など) の機能安全要件  
  - ISO 26262などの安全規格に準拠するために、**シングルビット誤りでの訂正**や**ダブルビット誤りの検知・迅速通知**をハードウェアで実現している。  
  - ハードウェアレベルでエラーを追跡し、ソフトウェアが安全側に倒す（リセット、フェイルセーフ動作を取る）仕組みが求められる。

- **産業機器向けマイコンやSoC**  
  - 産業向け安全規格（IEC 61508など）に対応するために、ECM相当の機能ブロックでメモリ保護やエラー監視を行う。

- **サーバー/PC向けSoC**  
  - ECCメモリコントローラを内蔵しているケースが多く、**Error Control/Correction Module**の一部機能を担うハードウェアIPが含まれていることがある。

---

## まとめ

- **ECM (Error Control Module)** は、主に  
  - **メモリやバス周りのエラー検出・訂正**（ECCなど）  
  - **検出したエラーの管理や通報**  
  - **安全動作を確保するためのハードウェア支援**  
  を集約した制御モジュールです。  

- **名称や詳細仕様はメーカーや製品で異なる** ため、たとえば「エラーコレクションユニット (Error Collection Unit)」「エラーマネジメントモジュール」など別の呼び方をしている場合もあります。

- 機能安全規格対応マイコンにおいては、**ECMがリアルタイムにエラーを監視し、安全対策を取る上での中核的な役割**を果たすことが多いです。
- 
## 1. SoC (System on a Chip) とは

- **SoC (System on a Chip)** とは、コンピュータシステムを構成する主要な機能（CPUコア、メモリ、各種I/O、周辺回路など）を**1つの半導体チップ上に集約**したものを指します。  
- **マイコン（MCU）** もSoCの一種ですが、一般的には「より多機能・高性能なプロセッサ(マルチコア)と大容量メモリ、各種IP（インターフェース回路やDSPブロックなど）」が統合されたものを**SoC** と呼ぶことが多いです。

### 例

- **携帯電話やスマートフォン** のメインチップ（アプリケーションプロセッサ）：CPU・GPU・ISP(画像処理)・DSP・各種I/O が一枚のチップに集まっている。  
- **産業用・車載用SoC**：メインCPUコア＋セーフティコア＋グラフィックス／AIアクセラレータなど、多数の機能をワンチップ化。

### マイコンとSoCの違い (ざっくり)

- **マイコン (MCU)**: 内蔵フラッシュメモリやRAM、簡易な周辺機能(ADC/UART等)を搭載したシングルコア／デュアルコアのシステム。組込み用途でリアルタイム性を重視。  
- **SoC**: より大規模・高機能で、**Linuxや複数OSを並行動作させる**などのアプリケーション向け。  
  - ただし、近年は**機能安全対応のSoC**も増えており、**マイコン的な安全機能**(ECC, WDT, ロックステップコア等)を内蔵する例があります。

---

## 2. ハンドラ (Handler) とは

- **ハンドラ (handler)** とは、**特定のイベントが発生した際に呼び出される処理ルーチン**（関数、プログラム片）のことを指します。  
- 組込みシステムでよく登場するのは、**割り込みハンドラ (interrupt handler)** や **例外ハンドラ (exception handler)** です。

### 割り込みハンドラ (Interrupt Handler)

- 割り込み(Interrupt)が発生した際に、CPUが**自動的に呼び出す**特別な関数です。  
- たとえば **タイマ割り込み** で定期的にシステム処理を呼び出したり、**UART割り込み** で受信完了を受け取ったりする。

### 例外ハンドラ (Exception Handler)

- CPUが**不正命令** や **不正アクセス**, **ゼロ除算** などに遭遇した場合の**例外処理**を行う関数。  
- 機能安全マイコンでは、**ECCで訂正できないエラー** や **ロックステップ不一致** を検出した際に**NMI (Non-Maskable Interrupt) あるいは例外**を発生させ、**例外ハンドラ**内で異常処理（リセット、ログ取得、フェイルセーフ動作）を行う場合が多いです。

### ハンドラが呼ばれる流れ（例: ECC二重ビットエラー）

1. マイコン内部の **ECCロジック** が「訂正不能エラー(ダブルビットエラー)」を検出。  
2. **ECM (Error Control Module)** や **割り込み制御器** に「エラー割り込み要求」を通知。  
3. CPUは実行中の命令を一時中断し、**割り込みベクタテーブル**などで定義された「エラーハンドラ (例: ECC_Error_Handler)」にジャンプ。  
4. ハンドラ関数内でログ収集やリセット指示を行う。

---

## まとめ

- **SoC (System on a Chip)** : CPUや各種周辺回路、メモリなどを単一チップに統合した大規模集積回路。マイコンより高機能化したものを指すケースが多い。  
- **ハンドラ (Handler)** : 特定イベント（割り込みや例外など）の際に呼ばれるプログラムルーチン。組込み開発では**割り込みハンドラ、例外ハンドラ**が代表例。

以上が、SoCとハンドラの基本的な説明になります。

以下、それぞれの用語について解説します。

---

## 1. SEC-DED とは？

**SEC-DED** は **Single Error Correction, Double Error Detection** の略称で、  
**メモリ上の1ビットエラーを自動訂正**し、**2ビット以上のエラーを検出**できるECC（Error Correction Code）の一種です。

### 具体的なイメージ

- **メモリ書き込み時**:  
  データ(例: 64ビット)に対して特定の計算を行い、複数ビット分の冗長データ（ECCビット）を生成して一緒に保存します。  
- **メモリ読み出し時**:  
  データ(64ビット)とECCビットを同時に取り出し、エラー訂正回路（デコーダ）がビット誤りを検出・訂正します。  
  - **1ビットの誤り** → 誤りが生じたビット位置を特定して自動で修正  
  - **2ビット以上の誤り** → 訂正はできないが「エラーが発生した」という検出フラグを立てる

これにより、**ソフトエラー**（放射線や電磁ノイズなどによる単ビット反転など）に対して高い耐性が得られます。

---

## 2. Flash ROM とは？

**Flash ROM（フラッシュメモリ）** は、**電源を切っても内容が消えない（不揮発性）メモリ**の一種です。  
- マイコン内部の**プログラム格納領域**として用いられ、従来の**ROM**や**EPROM**に代わって使われています。  
- データの**書き込み・消去**が電気的に行えるため、システムのソフトウェアアップデートや設定書き換えなどが容易です。  
- 一般的に「NANDフラッシュ」や「NORフラッシュ」など、様々な方式がありますが、マイコン内部では**主にNOR型フラッシュ**が採用されることが多いです。

### 特徴

- **不揮発性**: 電源オフでも内容を保持  
- **書き換え可能**: ただし書き込みや消去には特定の手順や待ち時間が必要  
- **大容量化が進む**: 近年のマイコンは数百KB～数MBレベルのFlashを内蔵することも珍しくありません

---

## 3. SRAM とは？

**SRAM（Static Random Access Memory）** は、**電源が供給されている間だけデータを保持**する**揮発性メモリ**です。  
- 「Static」の名のとおり、**DRAM**とは異なり**リフレッシュ**が不要です（内部のフリップフロップ構造でデータを保持）。  
- ただし、**集積度（容量あたりの面積）** はDRAMよりも大きく、高価になりがちです。  
- マイコンでは、**作業領域（スタックや変数格納など）** として**内蔵SRAM**を使うのが一般的です。

### 特徴

- **高速アクセス**: リフレッシュ不要なのでDRAMより速度が出しやすい  
- **容量に限界**: 同じチップ面積ならDRAMほど大容量化できない  
- **マイコン内蔵RAMとして主流**: 変数やバッファを置くための実行時メモリとして利用

---

## まとめ

- **SEC-DED**: Single Error Correction, Double Error Detection の略。  
  - 1ビットの誤りを訂正、2ビット以上は検出して警告するECC手法。

- **Flash ROM**: 不揮発性メモリの一種。  
  - マイコンのプログラム領域として使われる。  
  - 電気的に消去・書き込みが可能で、アップデートや書き換えに対応。

- **SRAM**: 揮発性メモリで電源オン時にデータを保持。  
  - リフレッシュ不要のため、アクセスが速い。  
  - マイコンの作業領域（変数やスタック）として用いられる。

これらはマイコンにおいて基本的な要素となるメモリ技術で、機能安全対応のマイコンではこれらの**メモリにECC（SEC-DED方式）**が適用されていることが多いです。

以下に、提示されたブロック図をベースにしつつ、**視認性を高めるためのレイアウト調整**および、一般的な機能安全マイコンに見られる**追加ブロック（MPU/Clock & Voltage Monitor等）**を加えたサンプル図を示します。  
同時に、「実際のマイコンと完全に一致する図ではない」点や、「シングルビットエラー（SBE）検出時は自動訂正・ログのみで割り込みを起こさない場合もある」などの注意点を追記して、誤解が生じないよう補足しています。

---

## 1. 図の全体概観とコメント

- **結論**: もとの図は**概念的には正しい**構成です。多くの機能安全対応マイコン(またはSoC)で、  
  1. **CPU (Lockstep)**  
  2. **Memory (Flash/ SRAM) + ECC**  
  3. **ECM (Error Control Module)**  
  4. **WDT (Watchdog Timer)**  
  5. **Interrupt Controller**  
  6. **Safety / Reset Controller**  
  といったブロックが連携してエラーを検出・処理し、最終的にフェイルセーフやリセットを行います。

- **可能な修正点 / 追加事項**:  
  1. **シングルビットエラー (Single-Bit Error, SBE)** は自動訂正されるが、必ずしもすぐに割り込みを起こさない場合がある。実装によっては「訂正した事実」をログだけに残すケースもある。  
  2. **バスエラー検出** や **MPU (Memory Protection Unit)** ブロックが省略されているので、機能安全マイコンではそれらも含めたエラー情報がECMに集約されることが多い。  
  3. **Clock & Voltage Monitor**（内部/外部オシレータの故障、電源低下の検出機能）がSafety/Reset Controllerに絡む場合がある。  
  4. **BIST (Built-In Self Test)** などの自己診断機能も起動時や定期的に走るが、図中には描かれていない。

---

## 2. 改良したテキストベースの詳細ブロック図

下記は、オリジナルの図をベースに**レイアウト調整・追加ブロック**を加えた例です。  
全体を**大きく3つのセクション**（CPUサブシステム、メモリサブシステム、セーフティ／リセットまわり）に分割し、**バスエラー/MPU/電源クロック監視**などの要素も追加しています。

```plaintext
┌──────────────────────────────┬───────────────────────────────[ External I/F ]──────────────────────────────┐
│ [ Other Peripherals / SoC   │                                                                      (ECU等) │
│   Integration]              │                                                                               │
└──────────────────────────────┴───────────────────────────────────────────────────────────────────────────────┘


┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                     [ 1) CPU Subsystem (Lockstep) ]                                       │
│                                                                                                            │
│     ┌─────────────────────────────┐       ┌──────────────────────────────┐                                 │
│     │ CORE0 (Main Execution)     │       │ CORE1 (Lockstep Mirror)      │                                 │
│     │ - 命令フェッチ/実行        │       │ - 同一命令を同期実行         │                                 │
│     │ - レジスタ/ALU演算        │       │ - 演算結果をComparatorへ     │                                 │
│     └─────────────┬─────────────┘       └─────────────┬──────────────┘                                 │
│                   │ (同期動作・同一バスアクセス)        │                                                 │
│                   ▼                                    ▼                                                 │
│     ┌─────────────────────────────────────────────────────────────────────────────┐                         │
│     │ Lockstep Comparator (LSC)                                                 │                         │
│     │  - CORE0/CORE1の演算/主要レジスタをリアルタイム比較                        │                         │
│     │  - 不一致 → "Lockstep Error" 信号(ls_error)                               │                         │
│     └─────────────────────────────────────────────────────────────────────────────┘                         │
│                   │                                                                                       │
│                   │ Lockstep Error                                                                         │
│                   ▼                                                                                       │
│     ┌─────────────────────────────────────────────────────────────────────────────┐                         │
│     │  CPU Internal Bus / AXI-AHB Bridge                                        │                         │
│     └─────────────────────────────────────────────────────────────────────────────┘                         │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     │ CPU命令/データアクセス (Flash/SRAM/Peripherals など)
                                     ▼

┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                [ 2) Memory Subsystem + ECC ]                                            │
│                                                                                                          │
│   ┌────────────────────────────────────────────────────────────────────────────────────────────────────┐   │
│   │ Flash ROM + ECC Logic                                                                            │   │
│   │  ┌─────────────────────────┐      ┌────────────────────────────────────────────────────────────┐  │   │
│   │  │ Flash Array (Code/Data) │ --->│ ECC Decoder/Encoder (e.g. SEC-DED)                          │  │   │
│   │  └─────────────────────────┘      └────────────────────────────────────────────────────────────┘  │   │
│   │    (1) 読み出し時、ECCを検査                                                                     │   │
│   │    (2) 1bit誤り → 自動訂正                                                                      │   │
│   │        2bit以上 → "Uncorrectable Error" フラグ                                                   │   │
│   └────────────────────────────────────────────────────────────────────────────────────────────────────┘   │
│   ▲                                                                                                      │
│   │ (SRAMも同様にECCありの場合)                                                                         │
│   └────────────────────────────────────────────────────────────────────────────────────────────────────┐   │
│       SRAM + ECC Logic                                                                                │   │
│        ┌─────────────────────────┐     ┌────────────────────────────────────────────────────────────┐ │   │
│        │ SRAM Array (Data/Buff) │ --->│ ECC Decoder/Encoder (SEC-DED)                               │ │   │
│        └─────────────────────────┘     └────────────────────────────────────────────────────────────┘ │   │
│          (1) CPU/DMACがR/W                                                                            │   │
│          (2) 1bit誤り → 自動訂正 & ステータス                                                          │   │
│              2bit以上 → "Uncorrectable Error" フラグ                                                  │   │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     │ ECCエラー (SBE/DBEステータス)
                                     ▼

┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                          [ ECM (Error Control Module) ]                                                  │
│    - ECCエラー(訂正不能/Double Error) フラグ受信                                                          │
│    - Lockstepエラー信号 (ls_error) 受信                                                                   │
│    - バスエラー, MPU違反, etc. を集約 (※ 追加要素)                                                       │
│    - エラー情報を割り込み制御器へ通知 / ログ取得                                                          │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     │ エラー時
                                     ▼

┌───────────────────────────────────────────────┬────────────────────────────────────────────────────────────┐
│ [ Interrupt Controller ]                     │  [ Safety / Reset Controller ]                            │
│  - ECMからのエラー割り込み要求               │  - ECMやWDTのリセット要求を受理                            │
│  - NMI/IRQとしてCPUがハンドラを実行          │  - システムリセットを発動、再起動                          │
│  - ソフトウェアによりログ/対策処理           │  - Clock & Voltage Monitor/Brown-out検出(※ 追加要素)      │
└───────────────────────────────────────────────┴────────────────────────────────────────────────────────────┘
   (CPUハンドラ中でフェイルセーフ移行やリセット指示を行う場合もある)


┌────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ [ WDT (Watchdog Timer) ]                                                                                 │
│  - ソフトウェアが定期的にリフレッシュ (WDT_Clear) しないとタイムアウト                                    │
│  - Window WDTの場合: 早過ぎるクリアもエラー検出                                                          │
│  - タイムアウト → Safety/Reset Controllerへリセット要求                                                 │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

```

---

## 3. 補足説明（主な修正・追加内容）

1. **正しくない箇所は特に見当たらないが、以下を補足**  
   - シングルビットエラー(SBE)は自動訂正後にエラーステータスだけ更新し、必ずしもNMIや割り込みを起こさない実装もある。  
   - ダブルビットエラー(DBE)や訂正不能エラー(UCE)は、ECMへ通知＆割り込みをトリガするのが典型的。  

2. **追加ブロック：MPU/バスエラー/クロック電源監視**  
   - 機能安全マイコンでは、**メモリプロテクションユニット (MPU)** や、**バスエラー検出**がECMに集約されることが多い。  
   - **クロック&電源監視 (Clock & Voltage/Brown-out Monitor)** を**Safety/Reset Controller**と連携させて、異常電圧やオシレータ停止時にリセットをかけるケースが多い。

3. **視認性向上**  
   - 大きく「CPU subsystem」「Memory subsystem」「ECM」「Interrupt & Safety/Reset」「WDT」の5つにセクション化し、横方向に余白を作っている。  
   - 各ブロック内に、箇条書きで機能説明やフローを簡潔にまとめた。  

---

## 4. まとめ

- **オリジナル図は概念的に問題なく、機能安全対応マイコンの代表的な構成を示している**と考えられます。  
- ただし、実際のマイコン製品やSoCでは、  
  - SBE（シングルビットエラー）検出時の割り込み発動の有無  
  - バスエラー/MPU保護がどこで行われるか  
  - クロック電源監視やその他安全機能がどのように統合されているか  
  - Lockstep Comparator が直接 Safety Controller に信号を送るか、ECM 経由で送るか  
  など、実装差があります。  
- そのため、最終的には**各マイコンのハードウェアマニュアル**や**安全マニュアル**を確認するのが重要です。  

以上が、修正・追記・視認性向上を行った結果のブロック図です。もしさらに詳細な機能（例：DMAサブシステム、キャッシュ、複数の割り込み制御階層など）を表現する場合は、同様の構成で追加ブロックを挿入していくとよいでしょう。

以下では、ご提示いただいた各機能項目について、

1. **概要（何をする機能か）**  
2. **目的（なぜ必要か、何を狙っているか）**  
3. **他機能とのつながり（どのように連携して安全性や信頼性を高めているか）**

を中心に整理して説明します。

---

## (1) CPUコアのロックステップ (Lock Step Mode)

### 概要
- **CPUコアが2つ**（または複数）用意されており、**同じ命令列を同期的に実行**し、両方の演算結果を常時比較する仕組みです。

### 目的
- **片方のコアが故障**（ビット反転や演算エラーなど）しても、もう一方のコアとの不一致が即座に検出できるため、**故障率（FITレート）を下げ**、**演算結果の信頼性**を向上させます。
- 自動車や産業機器など、**高い機能安全性**（ISO 26262、IEC 61508など）が要求される場面で用いられる手法です。

### 他機能とのつながり
- ロックステップコアが検出した**演算不一致**は、(3) の **FCCU** や (4) の **RCCU** などを通じて**エラー通知**が行われ、システムが安全側へ移行できるようになっています。

---

## (2) SoR（Sphere of Replication）による主要ブロックの冗長化

### 概要
- CPUコア以外の**主要な機能ブロック**(eDMA、クロスバースイッチなど)を**必ず2つ**搭載し、同じ処理を並行して行う、または一方が故障した場合に切り替えられるようにする**冗長化設計**です。

### 目的
- CPU以外のブロックが壊れても、もう1つの冗長ブロックで**システムを継続動作**できるようにして、**システムダウンのリスク**を低減します。
- ロックステップがCPUを二重化しているのと同様、**周辺モジュール**も冗長化することで、**トータルの安全度**を高めます。

### 他機能とのつながり
- (3) の **FCCU** から見れば、**SoRブロック**も故障検出対象に含まれます。  
- (4) の **RCCU** は、この**SoR構成**と連携してエラー状態を監視し、正常系と故障系を制御・切り替える役割を担います。

---

## (3) FCCU（Fault Collection and Control Unit）

### 概要
- システム内部で発生する**各種故障（Fault）**を**一元的に収集・管理**し、必要に応じて**エラー通知**や**リセット制御**を行うハードウェアモジュールです。

### 目的
- **ロックステップエラー**、**ECCエラー**、**バスエラー**など、マイコン内部の様々なエラーソースを集約し、**統一的に故障検出＆回復手続きを行う**ため。
- システムが安全側へ移行するためのトリガとして機能し、**機能安全規格**で要求される“故障検出率”や“フォールトトレランス”を実現します。

### 他機能とのつながり
- (4) の **RCCU** と連携してSoRブロックの状態を監視したり、(7) の **Watchdog Timer** や(10) の **MPU**からのエラー報告を受け取る場合もあります。  
- エラー検出後は**NMI**(9) を通じてCPUに通知したり、(12) の **PMU**経由でシステムリセットを掛けることもあります。

---

## (4) RCCU（Redundancy Control and Checker Unit）

### 概要
- **SoR（冗長化ブロック）** と (3) の **FCCU** を**結び付ける**ハードウェアモジュール。  
- 冗長化された各ブロックの**動作状態を監視**し、不一致や故障を検出したら**安全側の制御**を行う。

### 目的
- **冗長ブロックが正しく同期動作**しているかを常時チェックし、片方が故障したら**安全なもう一方のリソース**へ切り替えたり、**エラー通知**を行うことで**システムの継続性**を保つ。

### 他機能とのつながり
- RCCUはSoRブロック（(2)）からの**状態情報**を集め、(3) の **FCCU** へ**故障イベント**を報告。  
- その後、FCCUが(9) の **NMI**を発生させたり、(12) の **PMU** でリセットを制御するなどの一連の安全機能が動きます。

---

## (5) MBIST / LBIST（Built-In Self-Test for Memory / Logic）

### 概要
- **MBIST**: メモリ（RAM, フラッシュなど）を**内蔵の自己診断回路**によって起動時・定期的にテストし、**故障セル**の有無を検出する仕組み。  
- **LBIST**: CPUコアやSoRブロックなどの**論理回路**(Logic) をテストパターンで検証し、**回路レベルの故障**を検出する仕組み。

### 目的
- システムが**起動した時点**で主要ブロックが健全かどうかを**素早くチェック**するため。  
- **機能安全規格**では、一定のカバレッジを持ったセルフテストを行うことが要件になっている場合があります。

### 他機能とのつながり
- MBIST/LBISTによって検出された故障は、(3) **FCCU** に通知され、起動直後に**フェイルセーフ**や**再試行**などが行われます。  
- ソフトウェア側が(6) の**追加BIST機能**を呼び出してテストを実行する場合もあります。

---

## (6) ADC / Flash用BISTをソフトウェアから実行

### 概要
- (5) のMBIST / LBISTのハードウェア実行に加えて、**ADCやFlash専用の自己診断（BIST）機能**を**ソフトウェアから手動で起動**できる仕組み。

### 目的
- **起動時以外**にも必要なタイミングで**手動セルフテスト**を行い、誤差の蓄積やビット化けをいち早く発見する。  
- 例えば長時間稼働中のシステムで**定期点検**をソフトウェアから指示できる。

### 他機能とのつながり
- ソフトウェアがBISTを起動し、**異常検出**時は(3) の **FCCU** へエラーを通知し、(9) の **NMI** などでCPUを割り込ませる。  
- (13) の **CRCユニット** や(10) の **MPU** と組み合わせて、さらに高い検証精度を狙う場合もあります。

---

## (7) Watchdog Timer（二重化）

### 概要
- **ソフトウェアのハングアップ**や**暴走**を検出するための**ウォッチドッグタイマ**を**冗長化**（2系統）して搭載。  
- 2つのWDTが相互チェックしたり、一方が失敗しても他方がリセットを掛けられるように設計するケースもある。

### 目的
- **システム暴走**の際に**確実に再起動**や**安全停止**を行えるようにする。  
- 通常、1系統のWDTだけでもハング検出は可能だが、**WDT自体の故障**に備えて冗長化すると**信頼度**がさらに高まる。

### 他機能とのつながり
- WDTのタイムアウト信号は(3) の **FCCU** や(12) の **PMU**へ渡され、最終的に**リセット**や**安全制御**へつながります。  
- CPUや(10) の **MPU** で検知できないソフトウェアエラーをカバーする**最終防衛ライン**となります。

---

## (8) 接合部温度センサーの二重化

### 概要
- **チップ内部の接合部温度**（junction temperature）を監視するセンサーを**2系統**配置し、**片方故障**に備える冗長性。

### 目的
- 過熱が検出された際に**動作周波数を落とす**、**リセットを掛ける**などの対策を**確実に行う**ため。  
- 高温により半導体が物理的ダメージを受ける前に安全策を取る。

### 他機能とのつながり
- (3) の **FCCU** と連携して「温度異常」のエラーを記録・通報する場合もある。  
- (12) の **PMU** により**電圧レギュレータを制御**して発熱を抑える、あるいは**システムをシャットダウン**することが可能。

---

## (9) マスク不能割り込み（NMI: Non-maskable interrupt）

### 概要
- 通常の割り込み（優先度制御やマスクが可能）とは別に、**絶対に無視できない割り込みライン**(NMI) をサポート。  
- **致命的なエラー**が発生したときに**確実にCPU**を割り込ませ、**緊急処理**を行う。

### 目的
- どんなソフトウェアの状態（例：他の割り込みをマスク中、暴走中）であっても、**この割り込みだけは絶対に通す**ことで、安全性を確保。  
- 機能安全向けのCPUには標準搭載されるケースが多い。

### 他機能とのつながり
- (3) の **FCCU** や(1) の **Lockstepエラー**、(4) **RCCU** などがNMIを発動することがある。  
- NMIハンドラ内で(10) の **MPU**設定を変えたり、(12) の **PMU**を操作して**強制リセット**をかける場合もある。

---

## (10) 16リージョンのメモリ保護ユニット（MPU: Memory Protection Unit）

### 概要
- メモリ空間を**複数のリージョン**（この場合は16領域）に分割し、**読み出し/書き込み/実行**などのアクセス権を設定しておく。  
- 不正アクセスが発生した場合、**例外**や**エラー通知**を行い、システムを安全に保護する。

### 目的
- ソフトウェアの**バグ**や**外部攻撃**、**誤操作**による異常なメモリアクセスを防止。  
- データ破壊や機能暴走のリスクを**早期に検出**してシステム障害を局所化する。

### 他機能とのつながり
- MPU違反が起きると(3) の **FCCU** に情報が集約され、(9) の **NMI**や(7) の **WDT**でのリカバリに繋がる可能性もある。  
- 大域的なアクセス制御は(11) の **クロックモニタ**や(12) の **PMU**より上位レベルの存在ではありませんが、**協調して安全を確保**します。

---

## (11) クロックモニタユニット（CMU: Clock Monitoring Unit）

### 概要
- マイコン内部/外部の**クロック信号**（発振器、PLLなど）が**停止や異常周波数**になっていないかを監視するユニット。

### 目的
- **誤った周波数**や**クロック停止**が発生すると、CPUや周辺モジュールが暴走する危険があるため、**早期に発見**し**安全制御**を実施。

### 他機能とのつながり
- CMUで異常を検出すると(3) の **FCCU** へエラー報告し、(12) **PMU** を通じてクロックソース切り替えやリセットを掛ける場合もある。  
- (9) の **NMI** と組み合わせて即時対処するケースも。

---

## (12) 電源管理ユニット（PMU: Power management unit）

### 概要
- マイコン内部の**電源電圧レギュレータ**や**低電力モード制御**、**ブラウンアウト検出**などを行うユニット。  
- システム全体の**リセット制御**(POR, Soft reset など) も兼ねる場合が多い。

### 目的
- 電圧が規定範囲から外れた場合、**不安定動作**に陥らないよう**強制リセット**や**安全動作モード**へ移行する。  
- (8) の 温度センサー情報をもとに**熱暴走を回避**する策を講じたり、**低消費電力モード**への切り替えを管理する。

### 他機能とのつながり
- (3) の **FCCU** で致命的なエラーが見つかったとき、(12) の **PMU** が**リセットシーケンス**を開始する。  
- (11) の **CMU** や(1) の **Lockstep** も含め、どの機能ブロックがエラーを起こしても最終的に**PMU**が電源制御／リセットを担うケースが多い。

---

## (13) CRCユニット（Cyclic Redundancy Check）

### 概要
- **CRC計算**(Cyclic Redundancy Check) を**ハードウェアアクセラレータ**として搭載し、メモリ上のデータや通信データを**高速にチェック**できる。

### 目的
- **ソフトウェア**や**重要データ**の**破損検知**（フラッシュROM上のプログラムの定期チェックなど）を軽負荷で実行し、**信頼性**を高める。  
- 通信エラーや(5)(6) の BISTに加えて**ランタイムのデータ検証**を高速化。

### 他機能とのつながり
- CRCユニットは(6) の **BIST**テストや、起動時のソフトウェア整合性チェックに使用。  
- (10) の **MPU**で保護している領域に対し**CRCチェック**を行い、破損や改ざんを検出した際に(3) の **FCCU**へ通報し、(9) の **NMI**を発動するなどの流れが考えられます。

---

# 全体のまとめ

- **LockstepコアやSoR** による**ハードウェア冗長化**は、**CPU/主要ブロック**の演算・処理故障をリアルタイムに検知・回避するのが狙いです。  
- **FCCU** はシステム内の**エラー情報**を一元的に集約し、(9) NMI 発行や(12) PMU のリセット制御など**安全制御ルート**を切り開きます。  
- **RCCU** は SoR ブロックとの**連携（冗長制御・チェック）**を担い、**FCCU** へ繋ぐ役割を果たします。  
- **MBIST/LBIST/BIST** は起動時やソフト指示による**自己診断**を行い、不良部分を早期に検知。  
- **WDT二重化** はソフトウェア暴走を確実にリセットへ導く**最終防御**策。  
- **温度センサーの二重化** や **CMU/PMU** はハードウェア的環境異常（過熱、クロック異常、電圧異常）を監視し、安全側へ移行。  
- **MPU** はソフトウェア面の**不正アクセス**を制限し、**CRCユニット** はソフト/データ破損を検知するなど、合わせて**総合的に信頼性を高める**構成となっています。

以上のように、（1）～（13）の機能群が**相互補完**し合うことで、**多層的なセーフティアーキテクチャ**が構築され、**車載や産業用途**などで要求される高い安全性・信頼性を実現しているわけです。

以下に、(1)～(13)までの機能がどのように配置され、どのように繋がっているかを**テキスト（ASCII）ベースの概念図**としてまとめました。  
各ブロックに対応する番号を併記してあるので、先の説明と対応づけてご覧ください。

---

## 機能安全アーキテクチャ（テキストベースの例）

```plaintext
┌─────────────────────────────────────────────────────────────┐
│                   [ CPU Subsystem (Lockstep) ]             │  (1)
│   ┌────────────────────┐        ┌────────────────────┐     │
│   │ CORE0 (Main Exec.) │        │ CORE1 (Mirror)     │     │
│   │ 同期命令実行       │        │ 同期命令実行       │     │
│   └────────────┬───────┘        └───────┬────────────┘     │
│                │ (演算結果を比較)       │                   │
│                ▼                        ▼                   │
│       ┌──────────────────────────────────────────┐           │
│       │ Lockstep Comparator → "Lockstep Error"  │           │
│       └──────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────────┘
                         │
                         │ (Lockstep Error 信号)
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│         [ RCCU ] (4)                                          │
│   - SoRブロック(2)の冗長状態を管理                            │
│   - Lockstep/SoRの不一致報告を受理                            │
│   - 重大エラー時は FCCU(3)へ通知                              │
└─────────────────────────────────────────────────────────────────┘
                         │
                         │ (RCCUからのエラー通知)
                         ▼
┌──────────────────────────────────────────────────────────────────────────┐
│           [ FCCU ] (3)  Fault Collection & Control Unit                │
│   - システム全体のエラーを集約 (LockstepErr, ECCErr, SoRErr 等)        │
│   - エラー判定後: NMI(9) or Reset要求 etc.                              │
└──────────────────────────────────────────────────────────────────────────┘
                         │
                         │ 例) NMI発行 or Reset制御  (9)
                         ▼

            ┌─────────────────────────────────────────────┐
            │  [ Safety / Reset via PMU ] (12)           │
            │   - Power管理/リセット制御、ブラウンアウト │
            │   - クロックモニタ(CMU)(11)とも連携        │
            │   - 必要時にシステムリセット               │
            └─────────────────────────────────────────────┘
                                    ^
                                    |
        ┌────────────────────────────────────────────┐
        │  (11) [ CMU : Clock Monitoring Unit ]     │
        │   - クロック停止/異常周波数を検出          │
        │   - 異常時はFCCU or PMUへ通報              │
        └────────────────────────────────────────────┘
                                    ^
                                    |
┌────────────────────────────────────────┐
│ (8) 温度センサ(チップ内) 二重化       │
│   - 過熱時に警告 or システム抑制      │
│   - FCCU/PMUへ連動                    │
└────────────────────────────────────────┘


┌────────────────────────────────────────────────────────────────────────┐
│            [ SoRブロック (2) ]                                       │
│  例: eDMA, クロスバースイッチ 等を冗長化                             │
│  ┌─────────────┐    ┌─────────────┐                                 │
│  │ eDMA0        │    │ eDMA1        │  <-- 冗長化                    │
│  └─────────────┘    └─────────────┘                                 │
│  ┌────────────────┐  ┌────────────────┐                              │
│  │ CrossbarSwitch0│  │ CrossbarSwitch1│  <-- 冗長化                  │
│  └────────────────┘  └────────────────┘                              │
│   - RCCU(4)が両者の状態を監視, 故障を検出                            │
│   - 故障時に片系を切り離し or FCCU報告                                │
└────────────────────────────────────────────────────────────────────────┘


            ┌─────────────────────────────────────────────────┐
            │ [ Memory + BIST ]                               │
            │   - Flash / SRAM へのECC                        │
            │   - MBIST / LBIST (5): ハードウェアで自己診断    │
            │   - ADCやFlash用BIST(6): ソフトウェアで起動可能  │
            └─────────────────────────────────────────────────┘
                                    |
 (13) [CRCユニット]                 | ECCエラー (2bit以上) → FCCUへ
  - データ破損検出/検証             ▼
  - BIST後の検証にも利用   ┌─────────────────────────────────────────┐
                          │ ECCロジック (SEC-DED等)               │
                          │   1bit誤り自動訂正                     │
                          │   2bit以上 → "Uncorrectable Error"     │
                          └─────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│ (7) [ Watchdog Timer x2 ]                                                     │
│   - ハングアップ検出用WDTを冗長化                                             │
│   - いずれかが故障してももう1つで暴走リセット                                  │
│   - タイムアウトで FCCU→PMU リセット or NMI                                   │
└─────────────────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────────────────────┐
│ (10) [ MPU (16リージョン) ]                                                          │
│  - メモリ領域ごとにアクセス権設定 (R/W/X)                                             │
│  - 違反アクセス時は例外発生 → FCCU通報 → NMI or リセット                            │
│  - ソフト攻撃/バグによる不正書き込みを防止                                           │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

---

### 図の読み方

1. **CPU Subsystem (Lockstep)**  
   - 2つのコアが同じ命令を実行し、**Lockstep Comparator**が不一致を検出 → **Lockstep Error**。  
2. **SoR（冗長化ブロック群）**  
   - eDMAやクロスバースイッチなど主要周辺を**2系統**用意し、(4) **RCCU** で状態チェック。  
3. **RCCU → FCCU**  
   - SoR/Lockstepで検出したエラー情報を**FCCU**へ集約。  
4. **FCCU**  
   - ほかにも **WDT** タイムアウトや **ECCエラー**、 **MPU違反**、 **クロック異常 (CMU)**、 **温度過昇**など多数のエラーを一元管理し、**NMI**や**PMU**経由でリセット制御。  
5. **MBIST/LBIST/ソフトBIST**  
   - メモリや論理回路を起動時や定期で自己診断。  
6. **Watchdog Timer** (二重化)  
   - ソフトウェアハング時の**最終防衛ライン**。故障しても片方が動けば検出可能。  
7. **MPU (16リージョン)**  
   - ソフトウェアの**不正アクセス**を強制的にブロックし、**FCCU**へ通報。  
8. **CRCユニット**  
   - フラッシュプログラムやデータ領域の**破損検知**を高速実行。  
9. **CMU/PMU**  
   - クロック/電源の健全性監視、システムリセット管理。  
10. **温度センサー二重化**  
    - 過熱の早期検知をより確実にし、**PMU** で保護動作を実施。

このように、それぞれの機能が**相互連携**し、エラー発生時に**FCCU**を中心として**NMI**または**PMU**経由のリセットにより「安全側へ倒す」仕組みが構築されています。
