# 1. 用語の定義

### 基本の状態遷移用語

| 用語   | 英語                    | 簡単な定義                        | 補足・イメージ                        |
| ---- | --------------------- | ---------------------------- | ------------------------------ |
| 状態   | State                 | システムが「今どんな状況にいるか」を表す記憶情報     | 例：IDLE, WAIT, SEND など          |
| イベント | Event                 | 状態を変えたくなるきっかけとなる出来事          | 例：ボタンが押された、タイマが満了した、信号が1になった 等 |
| 入力   | Input                 | システムの外から与えられる信号・情報           | スイッチ信号、受信データ線、センサ値など           |
| 出力   | Output                | システムが外部に出す信号・情報              | LED点灯、制御信号、送信データなど             |
| 遷移   | Transition            | ある状態から別の状態へ「移る」こと            | 矢印で描かれる「状態A → 状態B」             |
| 遷移条件 | Transition Condition  | どのような入力・イベントのときに状態を遷移させるかの条件 | 例：`x=1 のとき A→B`                |
| 自己遷移 | Self-transition       | 状態が変わらず、自分自身へ遷移すること          | 例：`A → A`（一定条件が続く限り待機など）       |
| 初期状態 | Initial State         | リセット直後など、設計上「最初に必ず入る」状態      | 状態遷移図では矢印1本だけ刺さっている出発状態        |
| 終了状態 | Final/Accepting State | 動作が完了したことを表す状態（使わない設計も多い）    | プロトコル終了、エラーで停止など               |

---

### 設計表現・モデルに関する用語

| 用語    | 英語                     | 簡単な定義                      | 補足・イメージ                        |
| ----- | ---------------------- | -------------------------- | ------------------------------ |
| 状態遷移図 | State Diagram          | 状態を丸、遷移を矢印で表現した図           | 一番よく見るグラフィカルな表現                |
| 状態遷移表 | State Transition Table | 現状態・入力ごとの次状態・出力を表にしたもの     | 実装やロジック導出にそのまま使いやすい            |
| 状態変数  | State Variable         | 状態を内部で表現するビット列（レジスタ）       | 例：2ビットで S0=00, S1=01, S2=10 など |
| 状態符号化 | State Encoding         | 各状態にどのビットパターンを割り当てるかを決めること | バイナリ符号、one-hotなど               |
| ミーア型  | Mealy Machine          | 出力が「状態＋入力」に依存する状態機械        | 遷移の矢印上に`入力/出力`を記述することが多い       |
| ムーア型  | Moore Machine          | 出力が「状態だけ」に依存する状態機械         | 状態の丸の中に `出力` を書くことが多い          |

---

### ハードウェア実装寄りの用語（よく関連して出てくるもの）

| 用語        | 英語                   | 簡単な定義                     | 補足・イメージ                   |
| --------- | -------------------- | ------------------------- | ------------------------- |
| クロック      | Clock                | 状態更新のタイミングを決める周期信号        | 立ち上がり/立ち下がりのたびに次状態へ       |
| レジスタ / FF | Register / Flip-Flop | 状態変数などを記憶する順序素子           | 状態を保持する「箱」                |
| 同期式回路     | Synchronous Circuit  | クロックのタイミングに合わせてのみ状態が変わる回路 | 一般的なFSM実装の前提              |
| 非同期入力     | Asynchronous Input   | クロックと無関係に変化する入力信号         | スイッチ、外部信号など。メタステ対策が必要なことも |
| グリッチ      | Glitch               | 論理条件の変化の途中で出る一瞬だけの誤パルス    | Mealy機械の出力などで問題になりやすい     |
| ハザード      | Hazard               | グリッチが起こる潜在的な原因となる論理構造     | ロジックの経路差などによって発生          |

---

# 2. ミーア型，ムーア型

## 1. ミーア型（Mealy）状態機械

### 特徴

* **出力は「現在の状態 + 入力」に依存**
  → 遷移“の上”に出力を記述するイメージ
* 入力が変わった瞬間に、**状態が変わらなくても出力が変化し得る**
* 一般に、

  * 同じ機能なら **状態数が少なくて済みやすい**
  * その分、**出力がグリッチ（瞬間的な不安定）を起こしやすい**

### 設計手順（典型的な流れ）

1. **仕様の整理**

   * 入力信号・出力信号・動作条件（いつ何を出すか）を文章で整理。
2. **状態の定義**

   * 動作に必要な「記憶すべき状況」をステート名で定義
     例：IDLE, WAIT, SEND など
3. **状態遷移図の作成（Mealy 版）**

   * **状態ノード**：丸で状態を描く
   * **遷移矢印**：`入力条件 / 出力` のように矢印上に書く
     例：`x=1 / y=0`
4. **状態符号化（エンコード）**

   * 各状態に 0,1 のビットパターンを割り当てる（バイナリ・one-hot など）
5. **次状態・出力論理の導出**

   * 真理値表 or カルノー図で

     * 次状態関数：`Q_next = f(Q_current, Input)`
     * 出力関数：`Output = g(Q_current, Input)`
6. **回路 or HDL へ実装**

   * フリップフロップ（レジスタ）＋組み合わせ回路として構成
   * HDL(VHDL/Verilog/SystemVerilog等)なら `always_ff` + `always_comb` などで記述

---

## 2. ムーア型（Moore）状態機械

### 特徴

* **出力は「現在の状態」だけに依存**
  → 状態の“丸の中（または横）”に出力を記述するイメージ
* 入力が変わっても、**状態が変わるまで出力は変わらない**（クロック同期）
* 一般に、

  * 出力タイミングが入力に依存しないため **安定・扱いやすい**
  * 同じ機能を実現するのに **状態数が増えやすい**

### 設計手順（典型的な流れ）

1. **仕様の整理**

   * 入力・出力・シーケンスをテキストやタイミング図で整理。
2. **状態の定義**

   * 「どの出力を出す状態か」まで含めて状態を切る
     例：

     * S0: y=0
     * S1: y=1
       のように状態ごとに出力が決まるように設計
3. **状態遷移図の作成（Moore 版）**

   * 状態ノード：`状態名 / 出力` を丸の中に書く
     例：`S0 / y=0`, `S1 / y=1`
   * 遷移矢印：矢印上には **入力条件のみ**
     例：`x=1`
4. **状態符号化（エンコード）**

   * Mealy と同様にビット割り当て
5. **次状態・出力論理の導出**

   * 次状態関数：`Q_next = f(Q_current, Input)`
   * 出力関数：`Output = h(Q_current)`（入力に依らない）
6. **回路 or HDL へ実装**

   * 状態レジスタ＋組み合わせ回路
   * 出力は状態レジスタの値からのみ生成する

---

## 3. ざっくりした使い分けの目安

* **タイミングの安定性・設計の見通し重視 → ムーア型が基本**

  * 出力がクロック境界でしか変わらないので検証しやすい
* **状態数を減らしたい・応答をできるだけ速くしたい → ミーア型も検討**

  * 入力変化に即応できるが、グリッチ対策やタイミング解析が重要

---

# 3. ミーア型，ムーア型の使い分けの観点

## 0. ざっくり前提の再確認

* **ミーア型**：
  出力 = f(状態, 入力)
  → 入力が変わると、状態が変わらなくても出力が変わり得る（1クロック早く反応できる）。

* **ムーア型**：
  出力 = g(状態)
  → 出力変化は「状態遷移したとき（＝クロック境界）」に限られる（安定・読みやすい）。

この違いを「どんな仕様の時に、どっちの癖がハマるか」という観点で見ていきます。

---

## 1. 「応答速度」重視か、「出力の安定性」重視か

### 応答速度（レイテンシ）が重要な仕様 → ミーア型向き

**こんな仕様の特徴があるとき、ミーア型がハマりやすいです：**

* 「入力が立ったら**できるだけ早く**応答したい」

  * 例）`req` が 1 になった瞬間に `ack` を返したい
* 出力が「状態＋入力の組み合わせ」で自然に決まってしまう

  * 例）「状態 WAIT 中に `rx_valid=1` なら `rx_ack=1` を そのクロックで出す」
* 1クロック遅れるとプロトコル上不利になる、あるいは仕様として「同じサイクルに○○」と書かれている

**典型的な場面**

* シンプルなハンドシェイク（req/ack, valid/ready）
* シーケンス検出器（ビット列検出など）で、
  「最後のビットを受け取った**そのクロックで**検出信号を出したい」

  * Mealy だと N ビットのパターンを N 状態で検出できる
  * Moore だと N+1 状態になり、検出が 1 クロック遅れる

**ただし注意点**

* 入力の変化に依存するため、

  * 非同期入力をそのまま使うと**グリッチやメタステ**の危険が高い
  * 出力をそのまま外部へ出すより、一度レジスタに通してから出すことが多い（「見かけはムーア風」にする）

---

### 出力の安定性・読みやすさが重要 → ムーア型向き

**こんな仕様の特徴があるとき、ムーア型がハマりやすいです：**

* 「出力は**クロック境界でだけ変わる**こと」が強く求められる

  * 例）パワーシーケンスの制御、モータ制御、外部ICの制御線など
* 「状態 = 動作フェーズ = 出力の組み合わせ」という対応が明確

  * 例）`IDLE` 状態では「すべての制御信号 Low」、`ACTIVE` で「○○High」…といった仕様
* 後から仕様変更が入りそうで、**状態と出力の対応を見通しよく保ちたい**

**典型的な場面**

* 電源ON/OFFシーケンス、リセットシーケンス
* 外部バスプロトコルや IP コア制御（設定レジスタ書き込み手順など）
* 安全・安全回路（誤パルスで「危険な動作」が起きると困るところ）

**メリット**

* 出力は状態レジスタだけで決まるので

  * タイミング解析が楽
  * シミュレーション波形を追いやすい
  * フォーマル検証との相性も良い（状態→出力が一意）

---

## 2. 状態数・回路規模からの観点

### 状態数を減らしたい／仕様が複雑 → ミーア型が有利なことが多い

* Mealy は「状態は状況の記憶に限り、出力はその都度、入力と組み合わせて出す」ので

  * **状態数が少なくて済みやすい**
  * 結果としてレジスタ数が減る

**仕様の特徴**

* 「出力パターンが多いが、それぞれが細かい入力条件に依存する」
  → 状態として全部切ると **状態爆発**しそうなとき
* 「状態としては同じ状況だが、入力の値で細かく出力だけ変えたい」
  → Mealy なら状態1つ＋入力条件で表現しやすい

### 状態を増やしてもよい／わかりやすさ優先 → ムーア型が有利

* Moore は「出力パターンごとに状態を割り当てる」傾向になるので

  * **状態数は増えやすい**
  * ただし「この状態＝この出力」と言えるので**仕様との対応が直感的**

**仕様の特徴**

* ステップごとにやることがきれいに分かれている

  * 例）

    1. アドレス出力
    2. データ出力
    3. ウェイト
    4. 終了
* ドキュメントに「フェーズ1」「フェーズ2」…と書いてあり、各フェーズの出力が明確なとき

---

## 3. 仕様書の書き方から読み取る「勘所」

仕様書や口頭仕様から、「これはミーア？ムーア？」を判断するときのヒントです。

### ミーア型向きに聞こえるフレーズ

* 「状態 S の**間に**入力 X が '1' になったら、そのサイクルで出力 Y を立てる」
* 「X が '1' で、かつ今 S なら Y=1」
* 「ある状態で○○条件を満たした瞬間にパルスを出す」

→ 状態＋入力の組み合わせで **その瞬間** 出力が決まるイメージ。
　これをそのまま素直に書くと **ミーア的** になります。

### ムーア型向きに聞こえるフレーズ

* 「フェーズ1では A=1, B=0」「フェーズ2では A=0, B=1」といった**段階ごとの出力**が仕様にある
* 「○○状態中はこの出力を維持する」「次の状態に遷移したら××を出力」
* 「Nサイクル間この状態を維持してから次に進む」

→ フェーズ＝状態＝出力パターンで区切る方が自然なので、**ムーア的**に作った方が素直。

---

## 4. インタフェース・環境からの観点

### 外部との同期関係がカギ

**(1) 外部も同じクロックで同期している場合**

* 例えば SoC 内部のモジュール同士など

  * お互い、レジスタで入力を受けて「クロックエッジで」しか使わない設計になっている
* この場合、多少ミーア的な出力でも、最終的にはレジスタに食わせるので
  グリッチの影響は小さい／無くせることが多い

  * → ミーア型を使っても比較的安全に運用できる

**(2) 外部が非同期 or 別クロックの場合**

* 例：ボタン入力、外部ICからの非同期信号、別クロックドメインの信号など
* これらに対して、ミーア的に出力を変えると

  * 非同期変化 → 組み合わせ回路を通って **出力も非同期にフラつきやすい**
  * しかもそれがさらに別ブロックや外部ピンに出ると問題になりやすい
* → 基本は

  * 非同期入力は同期化フリップフロップに通す
  * 出力は状態レジスタからだけ作る（ムーア的にする）
  * **安全性重視ならムーア型が無難**

---

## 5. 実装・検証フローからの観点

### チームルール・ツールとの相性

* 大きなプロジェクト・会社では、コーディング規約で

  * 「基本はムーア型FSMで書くこと」
  * 「Mealy出力は必ずレジスタで同期してから外部へ」
    などを決めていることが多いです。
* 理由はシンプルで

  * 波形解析がしやすい
  * フォーマル検証や STA（タイミング解析）が楽
  * 「FSM = 状態レジスタ＋次状態ロジック＋出力ロジック」というパターンにハマる

→ こういう環境だと、**ベースはムーア**で設計し、
　「どうしても1サイクル速くしたいところだけ Mealy 出力＋レジスタ同期」という折衷案が多いです。

### デバッグのしやすさ

* ムーア型は

  * 「この状態のときにこの出力が出ているはず」という思考でデバッグできる
  * 状態を見れば「今何をしているか」が比較的一意
* ミーア型は

  * 「状態」＋「そのときの入力の組み合わせ」の両方を考えないといけない
  * バグの原因が「入力のタイミング」だったりするので、解析が少し面倒になることも

**→ 検証・保守を他の人がやることを考えると、「まずムーアで書く」が無難な戦略になりがちです。**

---

## 6. 結局どう選ぶ？ざっくり指針

かなり情報が増えたので、最後に「雑に決める時のフロー」をまとめます。

1. **まずムーア型で考えてみる**

   * 状態 = フェーズ = 出力パターン という形で仕様を整理

2. その上で、以下に当てはまる箇所があるかを見る
   → あれば、その部分だけミーア的にすることを検討

   * 1サイクルでも速く反応したい信号があるか？
   * ある状態の中で、入力によって瞬間的に出力が変わる仕様か？
   * 出力パターンの種類が多すぎて、状態が爆発しそうか？

3. 安全性・安定性に対する要求を確認する

   * 外部ピンに出る制御信号／アクチュエータ制御 → 基本ムーア（＋同期化）
   * 同一クロック内の SoC 内部信号 → Mealy も選択肢

4. チームルール・プロジェクト規模を考える

   * 一人で完結する小規模・実験レベル → Mealy を積極利用しても良い
   * 多人数開発・長期メンテナンス → ムーアベース＋必要箇所だけMealy

---

ミーア型・ムーア型それぞれを、そのままPFDツールに落とし込みやすい形で整理してみます。
（四角＝処理、ひし形＝判断、楕円＝開始／終了をイメージしてください）

---

# 4.ミーリ型，ムーア型設計手順

## 1. ミーア型（Mealy）FSM 設計 PFD

**▼ 全体のフロー**

```text
(開始)
  ↓
[処理] 仕様の確認・入出力信号の洗い出し
  ↓
[判断] 仕様にあいまい／矛盾はあるか？
  ├─ Yes → [処理] 仕様者と調整・仕様修正 → (上の判断に戻る)
  └─ No  → 続行
  ↓
[処理] 必要な状態の抽出・命名
  ↓
[処理] イベント／入力条件の整理
  ↓
[処理] Mealy 状態遷移図の作成
      ・状態ノードを配置
      ・遷移矢印に「入力条件 / 出力」を記述
  ↓
[処理] 状態遷移表の作成
      ・(現状態, 入力) → (次状態, 出力) を表形式に
  ↓
[処理] 状態符号化方式の決定
      ・バイナリ、one-hotなど
  ↓
[処理] 次状態論理・出力論理の導出
      ・真理値表 → 論理簡略化（カルノー図等）
      ・Q_next = f(Q_now, Input)
      ・Output = g(Q_now, Input)
  ↓
[処理] HDL／回路図への実装
      ・状態レジスタ
      ・組み合わせ回路（次状態・出力）
  ↓
[処理] シミュレーション・検証
      ・仕様どおりの遷移・出力か確認
      ・グリッチ／タイミングもチェック
  ↓
[判断] 問題はあるか？
  ├─ Yes → [処理] 仕様 or 設計の見直し → (必要なステップに戻る)
  └─ No  → 続行
  ↓
(終了)
```

---

## 2. ムーア型（Moore）FSM 設計 PFD

**ミーア型とほぼ共通ですが、「状態ごとに出力を決める」点が異なります。**

```text
(開始)
  ↓
[処理] 仕様の確認・入出力信号の洗い出し
  ↓
[判断] 仕様にあいまい／矛盾はあるか？
  ├─ Yes → [処理] 仕様者と調整・仕様修正 → (上の判断に戻る)
  └─ No  → 続行
  ↓
[処理] 必要な状態の抽出・命名
      ・「どの出力を出す状態か」まで含めて考える
  ↓
[処理] 各状態での出力値の決定
      ・State S0 → 出力A=0, B=1 …
      ・State S1 → 出力A=1, B=0 … など
  ↓
[処理] Moore 状態遷移図の作成
      ・状態ノードに「状態名 / 出力」を記述
        例： S0 / y=0, S1 / y=1
      ・遷移矢印には「入力条件のみ」を記述
  ↓
[処理] 状態遷移表の作成
      ・(現状態, 入力) → 次状態
      ・状態→出力 の対応表も作成
  ↓
[処理] 状態符号化方式の決定
      ・バイナリ、one-hotなど
  ↓
[処理] 次状態論理・出力論理の導出
      ・Q_next = f(Q_now, Input)
      ・Output = h(Q_now)  （入力に依存しない）
  ↓
[処理] HDL／回路図への実装
      ・状態レジスタ
      ・次状態生成回路
      ・状態レジスタだけから出力を生成
  ↓
[処理] シミュレーション・検証
      ・状態と出力が常に 1:1 に対応しているか
      ・クロック境界でのみ出力が変わるか 等を確認
  ↓
[判断] 問題はあるか？
  ├─ Yes → [処理] 仕様 or 設計の見直し → (必要なステップに戻る)
  └─ No  → 続行
  ↓
(終了)
```

---

### 補足：PFDとして描くときのコツ

* **共通部分（仕様整理〜状態抽出〜検証）はテンプレ化**しておき、
  「Mealy か Moore かで分岐する部分」だけを別レーンにする書き方もよく使われます。
* 図にするときは、

  * 上流：仕様・状態・イベント整理
  * 中盤：状態遷移図／表 → 符号化 → 論理導出
  * 下流：実装 → 検証
    という3ブロックくらいにまとめると見通しがよくなります。
