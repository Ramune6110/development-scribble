# 1.MISRA-C-2012 16の指針

## 1-1. MISRA-C指針のガイドライン

| 分類 | グループ               | 項番 | カテゴリ | ガイドライン                                                                                        | 詳細                                                      | 設計思想                           | 検証方法                                              | 備考                                     |
|:----:|:----------------------:|:----:|:--------:|:---------------------------------------------------------------------------------------------------|:---------------------------------------------------------|:----------------------------------|:-----------------------------------------------------|:----------------------------------------|
| 指針 | 処理系                 | 1.1  | 必要     | プログラムの出力が依存する処理系定義の動作は、文書化され、理解されなければならない                  | エンディアンや型幅などを明示的に共有                      | 移植性・信頼性の確保                | コードレビューで仕様コメント確認、Lint警告設定       | 公式文書 D-1.1参照                     |
| 指針 | コンパイルとビルド      | 2.1  | 必要     | すべてのソースファイルは、コンパイルエラーなしでコンパイルしなければならない                        | CIで常にクリーンビルドを維持                              | 品質保証・安定CI                   | CIログでエラー件数0を自動チェック                   | Docker環境統一                       |
| 指針 | 要件のトレーサビリティ  | 3.1  | 必要     | すべてのコードは文書化された要件へ追跡可能でなければならない                                      | 要件IDをコメントタグで紐付け                              | 変更漏れ防止・保守性向上            | トレースマトリクスとコードコメントを照合            | 要件ドキュメント連携必須               |
| 指針 | コード設計              | 4.1  | 必要     | 実行時の障害は最小限に抑えられなければならない (補足)                                             | malloc失敗時にもクラッシュしない                          | 信頼性維持                          | Lintで戻り値チェック警告有効化、コードレビュー確認 | 例外モジュールはDeviation申請要        |
| 指針 | コード設計              | 4.2  | 推奨     | アセンブリ言語のすべての使用は文書化されなければならない                                         | なぜASMかをコメント必須                                   | 可搬性・レビュー性向上               | レビューでDOC-ASMタグの有無をチェック              | ASMガイドライン策定済                 |
| 指針 | コード設計              | 4.3  | 必要     | アセンブリ言語は、カプセル化され、隔離されなければならない                                       | 専用モジュールにまとめる                                  | 保守性向上・依存管理                 | レビューで専用モジュールへの集約を確認              | assembly_utils.LIBに集約             |
| 指針 | コード設計              | 4.4  | 推奨     | コードの一部を「コメントアウト」してはならない                                                  | 古い実装はVCSで管理し、ソースには残さない                  | 可読性維持・レビューミス防止         | レビューで“//”コメント残存を検索                   | VCS運用ルール必須                      |
| 指針 | コード設計              | 4.5  | 推奨     | 可視性が重複して、同じ名前空間にある識別子は、表記上明白でなければならない (補足)                  | 似た名前は避け、区別しやすい命名を適用                   | 可読性向上                          | 命名規則チェックツールを実行                       | 命名規則ドキュメント参照               |
| 指針 | コード設計              | 4.6  | 推奨     | 基本的な数値型の代わりに、サイズと符号の有無を示すtypedefを使用しなければならない                  | stdint.h 型を typedef で明示                            | 安全性向上                          | Lintで基本型使用警告を有効化                      | LegacyはDeviation申請要               |
| 指針 | コード設計              | 4.7  | 必要     | 関数がエラー情報を返す場合は、そのエラー情報を判定しなければならない                             | 戻り値を無視しない                                        | 安全性向上                          | Lintで `unused return` 警告を有効化、レビュー確認  | 重要関数は例外禁止                    |
| 指針 | コード設計              | 4.8  | 推奨     | 構造体や共用体へのポインタが翻訳単位内で逆参照されることがない場合、オブジェクトの実装は隠されなければならない | ヘッダは不完全型のみ公開、実装を隠蔽                      | モジュール境界の強化                  | レビューで不完全型のみ公開を確認                   | インターフェイス仕様書要               |
| 指針 | コード設計              | 4.9  | 推奨     | 関数形式マクロの代わりに、互換性のある関数を使用しなければならない                             | inline 関数で置き換え                                    | 型安全性向上                        | レビューでマクロ使用箇所を検索                    | パフォーマンス例外申請要               |
| 指針 | コード設計              | 4.10 | 必要     | ヘッダファイルの内容が複数回インクルードされないように注意しなければならない                     | include guard / `#pragma once` を適用                  | ビルド安定化                        | Lintで include guard チェック                    | ガード命名規則適用                    |
| 指針 | コード設計              | 4.11 | 必要     | ライブラリ関数に渡す値の妥当性を確認しなければならない                                         | `strcpy` や `scanf` で長さチェック                       | バッファオーバーフロー防止            | Lintで unsafe 関数警告を有効化                   | 安全関数リスト連動                    |
| 指針 | コード設計              | 4.12 | 必要     | 動的なメモリ割り当てを使用してはならない                                                        | 静的配列またはメモリプール方式を使用                   | リアルタイム性・断片化防止            | レビューで `malloc`/`free` 使用を検索             | プール例外申請要                      |
| 指針 | コード設計              | 4.13 | 推奨     | リソースに対する操作を提供するように設計された関数は、適切な順序で呼び出さなければならない (補足)      | `init` → `use` → `deinit` の順序を守る                 | 状態管理の明確化                     | レビューで呼び出し順序をチェック                  | State Machine 連携要                   |

## 1-2. ガイドライン逸脱例 & 適用例

### 指針1.1：処理系依存の文書化

* **逸脱例**

  ```c
  // バイトオーダーを考慮せずに直接読み込む
  uint8_t buffer[2] = {0x34, 0x12};
  uint16_t value = *(uint16_t*)buffer;
  ```
* **適用例**

  ```c
  // リトルエンディアンとして明示的に組み立てる
  uint8_t buffer[2] = {0x34, 0x12};
  uint16_t value =
      (uint16_t)buffer[0]
    | (uint16_t)buffer[1] << 8;
  ```

### 指針2.1：クリーンビルドの維持

* **逸脱例**

  ```c
  // 'x' が宣言されていない → コンパイルエラー
  int compute(void) {
      x = 5;
      return x;
  }
  ```
* **適用例**

  ```c
  // 変数を正しく宣言
  int compute(void) {
      int x = 5;
      return x;
  }
  ```

### 指針3.1：要件トレーサビリティ

* **逸脱例**

  ```c
  // 何の要件か不明な sum 関数
  int sum(int a, int b) {
      return a + b;
  }
  ```
* **適用例**

  ```c
  /**
   * @req REQ-001: 引数 a, b を加算して返す
   */
  int sum(int a, int b) {
      return a + b;
  }
  ```

### 指針4.1：実行時障害の抑制

* **逸脱例**

  ```c
  #include <stdlib.h>
  int* create_array(int n) {
      int* arr = malloc(n * sizeof(int));
      arr[0] = 0;  // malloc 失敗時に NULL 参照 → クラッシュ
      return arr;
  }
  ```
* **適用例**

  ```c
  #include <stdlib.h>
  #include <stdio.h>
  int* create_array(int n) {
      int* arr = malloc(n * sizeof(int));
      if (arr == NULL) {
          fprintf(stderr, "メモリ確保失敗\n");
          return NULL;
      }
      arr[0] = 0;
      return arr;
  }
  ```

### 指針4.2：ASM の文書化

* **逸脱例**

  ```c
  void wait_cycles(void) {
      __asm__("NOP");  // なぜ使っているか不明
  }
  ```
* **適用例**

  ```c
  /**
   * DOC-ASM-001: タイミング調整のため 1 命令 NOP を使用
   */
  void wait_cycles(void) {
      __asm__("NOP");
  }
  ```

### 指針4.3：ASM のカプセル化

* **逸脱例**

  ```c
  __asm__("MOV R0, #0");  // 散在している ASM コード
  ```
* **適用例**

  ```c
  // asm_util.c
  void clear_register(void) {
      __asm__("MOV R0, #0");
  }

  // main.c
  extern void clear_register(void);
  void init(void) {
      clear_register();
  }
  ```

### 指針4.4：コメントアウト禁止

* **逸脱例**

  ```c
  // int old_val = old_calc();  // 古い実装を残すためコメントアウト
  int val = new_calc();
  ```
* **適用例**

  ```c
  // 古い実装は Git 履歴から参照可能
  int val = new_calc();
  ```

### 指針4.5：識別子の明確化

* **逸脱例**

  ```c
  int data;
  float Data;  // 大文字小文字のみ違い → 紛らわしい
  ```
* **適用例**

  ```c
  int sensor_count;
  float average_value;
  ```

### 指針4.6：typedef の活用

* **逸脱例**

  ```c
  int value;  // int のサイズは環境依存
  ```
* **適用例**

  ```c
  #include <stdint.h>
  int32_t value;  // 明示的に 32 ビット符号付き
  ```

### 指針4.7：戻り値チェック

* **逸脱例**

  ```c
  int status = do_work();
  // status をチェックしない → エラーを見逃す
  ```
* **適用例**

  ```c
  int status = do_work();
  if (status != 0) {
      // エラー処理
  }
  ```

### 指針4.8：実装の隠蔽

* **逸脱例**

  ```c
  // header.h
  typedef struct Data {
      int x;
      int y;
  } Data;
  // main.c
  Data* d = get_data();
  d->x = 1;  // 実装が隠されていない
  ```
* **適用例**

  ```c
  // header.h
  typedef struct Data Data;
  Data* get_data(void);
  int get_x(const Data* d);

  // data.c
  struct Data {
      int x;
      int y;
  };
  ```

### 指針4.9：inline 関数の推奨

* **逸脱例**

  ```c
  #define SQUARE(x) ((x)*(x))
  ```
* **適用例**

  ```c
  static inline int square(int x) {
      return x * x;
  }
  ```

### 指針4.10：多重インクルード防止

* **逸脱例**

  ```c
  // header.h (ガードなし)
  int foo(void);
  ```
* **適用例**

  ```c
  // header.h
  #ifndef HEADER_H
  #define HEADER_H

  int foo(void);

  #endif  // HEADER_H
  ```

### 指針4.11：ライブラリ関数引数チェック

* **逸脱例**

  ```c
  char buf[8];
  scanf("%s", buf);  // バッファ長チェックなし
  ```
* **適用例**

  ```c
  char buf[8];
  scanf("%7s", buf);  // 最大7文字＋終端文字
  ```

### 指針4.12：動的メモリ禁止

* **逸脱例**

  ```c
  char* buf = malloc(256);  // 動的確保
  ```
* **適用例**

  ```c
  char buf[256];  // 静的確保
  ```

### 指針4.13：リソース操作の順序

* **逸脱例**

  ```c
  shutdown_device();
  start_device();  // 順序逆 → 混乱
  ```
* **適用例**

  ```c
  start_device();
  use_device();
  shutdown_device();  // 正しい順序
  ```

# 2.MISRA-C-2012 143のルール

## 2-1. 標準C環境

| 分類 | グループ         | 項番 | カテゴリ | ガイドライン                                                                                      | 詳細                                            | 設計思想                       | 検証方法                                      | 備考                         |
|:----:|:----------------:|:----:|:--------:|:-------------------------------------------------------------------------------------------------|:-----------------------------------------------|:------------------------------|:---------------------------------------------|:----------------------------|
| ルール | 標準C環境       | 1.1  | 必要     | プログラムは標準Cの構文と制約の違反が含まれていないものとし、処理系の翻訳限界を超えてはならない        | 標準Cの文法・翻訳限界（識別子長など）を厳守      | 移植性・互換性の確保          | 静的解析で標準C警告（–pedantic）を有効化       | 翻訳限界：31文字識別子等の仕様 |
| ルール | 標準C環境       | 1.2  | 推奨     | 言語拡張を使用してはいけない (補足)                                                                 | ベンダー拡張（属性／ASM／typeof等）を禁止        | 非標準機能依存排除            | コンパイラの–Werror=pedantic-errors を設定  |                            |
| ルール | 標準C環境       | 1.3  | 必要     | 未定義の動作またはクリティカルな未規定の動作の発生があってはならない (補足)                            | 仕様上「未定義」とされる挙動を一切含まない       | 安全性・予測可能性の担保      | UBSan, 静的解析のUB検出オプションを有効化    |                            |

### 2-1-1.ガイドライン逸脱例 & 適用例

### ルール1.1：標準C構文と翻訳限界
* **逸脱例** 
  ```c
  /* 識別子が 31 文字を超え、
     環境によっては末尾が切られて衝突の恐れあり */
  int this_is_a_very_long_function_name_exceeding_thirty_one_chars(int x) {
      return x;
  }
  ```
* **適用例**

  ```c
  /* 31 文字以内に収めた名前 */
  int this_is_long_func_name(int x) {
      return x;
  }
  ```

---

### ルール1.2：言語拡張禁止

* **逸脱例**

  ```c
  /* GCC の属性拡張を使用 */
  int func(void) __attribute__((noreturn));
  ```
* **適用例**

  ```c
  /* 純粋な標準C */
  void func(void);
  ```

---

### ルール1.3：未定義/未規定動作禁止

* **逸脱例**

  ```c
  #include <limits.h>
  int x = INT_MAX;
  /* INT_MAX + 1 は符号付き整数のオーバーフローで未定義動作 */
  int y = x + 1;
  ```
* **適用例**

  ```c
  #include <limits.h>
  int x = INT_MAX;
  int y;
  /* オーバーフローを回避するチェックを行う */
  if (x < INT_MAX) {
      y = x + 1;
  } else {
      /* エラー処理 */
      y = INT_MAX;
  }
  ```

```
```
