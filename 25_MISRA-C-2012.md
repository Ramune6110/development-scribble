# 1.MISRA-C-2012 16の指針

## 1-1. MISRA-C指針のガイドライン

| 分類 | グループ               | 項番 | カテゴリ | ガイドライン                                                                                        | 詳細                                                      | 設計思想                           | 検証方法                                              | 備考                                     |
|:----:|:----------------------:|:----:|:--------:|:---------------------------------------------------------------------------------------------------|:---------------------------------------------------------|:----------------------------------|:-----------------------------------------------------|:----------------------------------------|
| 指針 | 処理系                 | 1.1  | 必要     | プログラムの出力が依存する処理系定義の動作は、文書化され、理解されなければならない                  | エンディアンや型幅などを明示的に共有                      | 移植性・信頼性の確保                | コードレビューで仕様コメント確認、Lint警告設定       | 公式文書 D-1.1参照                     |
| 指針 | コンパイルとビルド      | 2.1  | 必要     | すべてのソースファイルは、コンパイルエラーなしでコンパイルしなければならない                        | CIで常にクリーンビルドを維持                              | 品質保証・安定CI                   | CIログでエラー件数0を自動チェック                   | Docker環境統一                       |
| 指針 | 要件のトレーサビリティ  | 3.1  | 必要     | すべてのコードは文書化された要件へ追跡可能でなければならない                                      | 要件IDをコメントタグで紐付け                              | 変更漏れ防止・保守性向上            | トレースマトリクスとコードコメントを照合            | 要件ドキュメント連携必須               |
| 指針 | コード設計              | 4.1  | 必要     | 実行時の障害は最小限に抑えられなければならない (補足)                                             | malloc失敗時にもクラッシュしない                          | 信頼性維持                          | Lintで戻り値チェック警告有効化、コードレビュー確認 | 例外モジュールはDeviation申請要        |
| 指針 | コード設計              | 4.2  | 推奨     | アセンブリ言語のすべての使用は文書化されなければならない                                         | なぜASMかをコメント必須                                   | 可搬性・レビュー性向上               | レビューでDOC-ASMタグの有無をチェック              | ASMガイドライン策定済                 |
| 指針 | コード設計              | 4.3  | 必要     | アセンブリ言語は、カプセル化され、隔離されなければならない                                       | 専用モジュールにまとめる                                  | 保守性向上・依存管理                 | レビューで専用モジュールへの集約を確認              | assembly_utils.LIBに集約             |
| 指針 | コード設計              | 4.4  | 推奨     | コードの一部を「コメントアウト」してはならない                                                  | 古い実装はVCSで管理し、ソースには残さない                  | 可読性維持・レビューミス防止         | レビューで“//”コメント残存を検索                   | VCS運用ルール必須                      |
| 指針 | コード設計              | 4.5  | 推奨     | 可視性が重複して、同じ名前空間にある識別子は、表記上明白でなければならない (補足)                  | 似た名前は避け、区別しやすい命名を適用                   | 可読性向上                          | 命名規則チェックツールを実行                       | 命名規則ドキュメント参照               |
| 指針 | コード設計              | 4.6  | 推奨     | 基本的な数値型の代わりに、サイズと符号の有無を示すtypedefを使用しなければならない                  | stdint.h 型を typedef で明示                            | 安全性向上                          | Lintで基本型使用警告を有効化                      | LegacyはDeviation申請要               |
| 指針 | コード設計              | 4.7  | 必要     | 関数がエラー情報を返す場合は、そのエラー情報を判定しなければならない                             | 戻り値を無視しない                                        | 安全性向上                          | Lintで `unused return` 警告を有効化、レビュー確認  | 重要関数は例外禁止                    |
| 指針 | コード設計              | 4.8  | 推奨     | 構造体や共用体へのポインタが翻訳単位内で逆参照されることがない場合、オブジェクトの実装は隠されなければならない | ヘッダは不完全型のみ公開、実装を隠蔽                      | モジュール境界の強化                  | レビューで不完全型のみ公開を確認                   | インターフェイス仕様書要               |
| 指針 | コード設計              | 4.9  | 推奨     | 関数形式マクロの代わりに、互換性のある関数を使用しなければならない                             | inline 関数で置き換え                                    | 型安全性向上                        | レビューでマクロ使用箇所を検索                    | パフォーマンス例外申請要               |
| 指針 | コード設計              | 4.10 | 必要     | ヘッダファイルの内容が複数回インクルードされないように注意しなければならない                     | include guard / `#pragma once` を適用                  | ビルド安定化                        | Lintで include guard チェック                    | ガード命名規則適用                    |
| 指針 | コード設計              | 4.11 | 必要     | ライブラリ関数に渡す値の妥当性を確認しなければならない                                         | `strcpy` や `scanf` で長さチェック                       | バッファオーバーフロー防止            | Lintで unsafe 関数警告を有効化                   | 安全関数リスト連動                    |
| 指針 | コード設計              | 4.12 | 必要     | 動的なメモリ割り当てを使用してはならない                                                        | 静的配列またはメモリプール方式を使用                   | リアルタイム性・断片化防止            | レビューで `malloc`/`free` 使用を検索             | プール例外申請要                      |
| 指針 | コード設計              | 4.13 | 推奨     | リソースに対する操作を提供するように設計された関数は、適切な順序で呼び出さなければならない (補足)      | `init` → `use` → `deinit` の順序を守る                 | 状態管理の明確化                     | レビューで呼び出し順序をチェック                  | State Machine 連携要                   |

## 1-2. ガイドライン逸脱例 & 適用例

### 指針1.1：処理系依存の文書化

* **逸脱例**

  ```c
  // バイトオーダーを考慮せずに直接読み込む
  uint8_t buffer[2] = {0x34, 0x12};
  uint16_t value = *(uint16_t*)buffer;
  ```
* **適用例**

  ```c
  // リトルエンディアンとして明示的に組み立てる
  uint8_t buffer[2] = {0x34, 0x12};
  uint16_t value =
      (uint16_t)buffer[0]
    | (uint16_t)buffer[1] << 8;
  ```

### 指針2.1：クリーンビルドの維持

* **逸脱例**

  ```c
  // 'x' が宣言されていない → コンパイルエラー
  int compute(void) {
      x = 5;
      return x;
  }
  ```
* **適用例**

  ```c
  // 変数を正しく宣言
  int compute(void) {
      int x = 5;
      return x;
  }
  ```

### 指針3.1：要件トレーサビリティ

* **逸脱例**

  ```c
  // 何の要件か不明な sum 関数
  int sum(int a, int b) {
      return a + b;
  }
  ```
* **適用例**

  ```c
  /**
   * @req REQ-001: 引数 a, b を加算して返す
   */
  int sum(int a, int b) {
      return a + b;
  }
  ```

### 指針4.1：実行時障害の抑制

* **逸脱例**

  ```c
  #include <stdlib.h>
  int* create_array(int n) {
      int* arr = malloc(n * sizeof(int));
      arr[0] = 0;  // malloc 失敗時に NULL 参照 → クラッシュ
      return arr;
  }
  ```
* **適用例**

  ```c
  #include <stdlib.h>
  #include <stdio.h>
  int* create_array(int n) {
      int* arr = malloc(n * sizeof(int));
      if (arr == NULL) {
          fprintf(stderr, "メモリ確保失敗\n");
          return NULL;
      }
      arr[0] = 0;
      return arr;
  }
  ```

### 指針4.2：ASM の文書化

* **逸脱例**

  ```c
  void wait_cycles(void) {
      __asm__("NOP");  // なぜ使っているか不明
  }
  ```
* **適用例**

  ```c
  /**
   * DOC-ASM-001: タイミング調整のため 1 命令 NOP を使用
   */
  void wait_cycles(void) {
      __asm__("NOP");
  }
  ```

### 指針4.3：ASM のカプセル化

* **逸脱例**

  ```c
  __asm__("MOV R0, #0");  // 散在している ASM コード
  ```
* **適用例**

  ```c
  // asm_util.c
  void clear_register(void) {
      __asm__("MOV R0, #0");
  }

  // main.c
  extern void clear_register(void);
  void init(void) {
      clear_register();
  }
  ```

### 指針4.4：コメントアウト禁止

* **逸脱例**

  ```c
  // int old_val = old_calc();  // 古い実装を残すためコメントアウト
  int val = new_calc();
  ```
* **適用例**

  ```c
  // 古い実装は Git 履歴から参照可能
  int val = new_calc();
  ```

### 指針4.5：識別子の明確化

* **逸脱例**

  ```c
  int data;
  float Data;  // 大文字小文字のみ違い → 紛らわしい
  ```
* **適用例**

  ```c
  int sensor_count;
  float average_value;
  ```

### 指針4.6：typedef の活用

* **逸脱例**

  ```c
  int value;  // int のサイズは環境依存
  ```
* **適用例**

  ```c
  #include <stdint.h>
  int32_t value;  // 明示的に 32 ビット符号付き
  ```

### 指針4.7：戻り値チェック

* **逸脱例**

  ```c
  int status = do_work();
  // status をチェックしない → エラーを見逃す
  ```
* **適用例**

  ```c
  int status = do_work();
  if (status != 0) {
      // エラー処理
  }
  ```

### 指針4.8：実装の隠蔽

* **逸脱例**

  ```c
  // header.h
  typedef struct Data {
      int x;
      int y;
  } Data;
  // main.c
  Data* d = get_data();
  d->x = 1;  // 実装が隠されていない
  ```
* **適用例**

  ```c
  // header.h
  typedef struct Data Data;
  Data* get_data(void);
  int get_x(const Data* d);

  // data.c
  struct Data {
      int x;
      int y;
  };
  ```

### 指針4.9：inline 関数の推奨

* **逸脱例**

  ```c
  #define SQUARE(x) ((x)*(x))
  ```
* **適用例**

  ```c
  static inline int square(int x) {
      return x * x;
  }
  ```

### 指針4.10：多重インクルード防止

* **逸脱例**

  ```c
  // header.h (ガードなし)
  int foo(void);
  ```
* **適用例**

  ```c
  // header.h
  #ifndef HEADER_H
  #define HEADER_H

  int foo(void);

  #endif  // HEADER_H
  ```

### 指針4.11：ライブラリ関数引数チェック

* **逸脱例**

  ```c
  char buf[8];
  scanf("%s", buf);  // バッファ長チェックなし
  ```
* **適用例**

  ```c
  char buf[8];
  scanf("%7s", buf);  // 最大7文字＋終端文字
  ```

### 指針4.12：動的メモリ禁止

* **逸脱例**

  ```c
  char* buf = malloc(256);  // 動的確保
  ```
* **適用例**

  ```c
  char buf[256];  // 静的確保
  ```

### 指針4.13：リソース操作の順序

* **逸脱例**

  ```c
  shutdown_device();
  start_device();  // 順序逆 → 混乱
  ```
* **適用例**

  ```c
  start_device();
  use_device();
  shutdown_device();  // 正しい順序
  ```

# 2.MISRA-C-2012 143のルール

## 2-1. 標準C環境

| 分類 | グループ         | 項番 | カテゴリ | ガイドライン                                                                                      | 詳細                                            | 設計思想                       | 検証方法                                      | 備考                         |
|:----:|:----------------:|:----:|:--------:|:-------------------------------------------------------------------------------------------------|:-----------------------------------------------|:------------------------------|:---------------------------------------------|:----------------------------|
| ルール | 標準C環境       | 1.1  | 必要     | プログラムは標準Cの構文と制約の違反が含まれていないものとし、処理系の翻訳限界を超えてはならない        | 標準Cの文法・翻訳限界（識別子長など）を厳守      | 移植性・互換性の確保          | 静的解析で標準C警告（–pedantic）を有効化       | 翻訳限界：31文字識別子等の仕様 |
| ルール | 標準C環境       | 1.2  | 推奨     | 言語拡張を使用してはいけない (補足)                                                                 | ベンダー拡張（属性／ASM／typeof等）を禁止        | 非標準機能依存排除            | コンパイラの–Werror=pedantic-errors を設定  |                            |
| ルール | 標準C環境       | 1.3  | 必要     | 未定義の動作またはクリティカルな未規定の動作の発生があってはならない (補足)                            | 仕様上「未定義」とされる挙動を一切含まない       | 安全性・予測可能性の担保      | UBSan, 静的解析のUB検出オプションを有効化    |                            |

## ガイドライン逸脱例 & 適用例

### ルール1.1：標準C構文と翻訳限界
* **逸脱例** 
  ```c
  /* 識別子が 31 文字を超え、
     環境によっては末尾が切られて衝突の恐れあり */
  int this_is_a_very_long_function_name_exceeding_thirty_one_chars(int x) {
      return x;
  }
  ```
* **適用例**

  ```c
  /* 31 文字以内に収めた名前 */
  int this_is_long_func_name(int x) {
      return x;
  }
  ```

---

### ルール1.2：言語拡張禁止

* **逸脱例**

  ```c
  /* GCC の属性拡張を使用 */
  int func(void) __attribute__((noreturn));
  ```
* **適用例**

  ```c
  /* 純粋な標準C */
  void func(void);
  ```

---

### ルール1.3：未定義/未規定動作禁止

* **逸脱例**

  ```c
  #include <limits.h>
  int x = INT_MAX;
  /* INT_MAX + 1 は符号付き整数のオーバーフローで未定義動作 */
  int y = x + 1;
  ```
* **適用例**

  ```c
  #include <limits.h>
  int x = INT_MAX;
  int y;
  /* オーバーフローを回避するチェックを行う */
  if (x < INT_MAX) {
      y = x + 1;
  } else {
      /* エラー処理 */
      y = INT_MAX;
  }
  ```
## 2-2. 未使用コード

| 分類  | グループ     | 項番 | カテゴリ | ガイドライン                                                            | 詳細                                                | 設計思想                    | 検証方法                                 | 備考               |
|:----:|:------------:|:----:|:--------:|:-----------------------------------------------------------------------|:---------------------------------------------------|:---------------------------|:----------------------------------------|:------------------|
| ルール | 未使用コード | 2.1  | 必要     | プロジェクトは到達不能なコードを含んではならない                        | `return`以降など、絶対に実行されない部分を除去        | 無駄なコードを排除し品質向上 | 静的解析で到達不能コードを検出           |                    |
| ルール | 未使用コード | 2.2  | 必要     | デッドコードがあってはならない                                          | 呼び出されない関数や変数を除去                        | 可読性・保守性の向上       | 静的解析で未参照関数／変数を検出         |                    |
| ルール | 未使用コード | 2.3  | 推奨     | プロジェクトは未使用の型宣言を含んではならない                          | 定義だけして使われない `typedef` を削除                | コード簡素化                | 静的解析で未参照型を検出                |                    |
| ルール | 未使用コード | 2.4  | 推奨     | プロジェクトは未使用のタグ宣言を含んではならない                        | `struct`/`union` タグを定義だけして使わない場合は削除 | コード簡素化                | 静的解析で未参照タグを検出              |                    |
| ルール | 未使用コード | 2.5  | 推奨     | プロジェクトは未使用のマクロ宣言を含んではならない                      | 定義だけして使わない `#define` を削除                  | コード簡素化                | Lint で未使用マクロを検出               |                    |
| ルール | 未使用コード | 2.6  | 推奨     | プロジェクトは未使用のラベル宣言を含んではならない                      | `goto` 先がないラベルを削除                            | 可読性・保守性の向上       | コンパイラ警告／静的解析で未使用ラベル検出 |                    |
| ルール | 未使用コード | 2.7  | 推奨     | 関数内に未使用のパラメータがあってはならない                            | 使わないパラメータは削除、または `(void)param;` で明示 | API 仕様の明確化            | Lint で unused-parameter 警告を有効化    |                    |

## ガイドラインの逸脱例 & 適用例

### ルール2.1：到達不能なコード
* **逸脱例**

  ```c
  void example(void) {
      printf("Start\n");
      return;
      printf("これは実行されない\n");  // 到達不能
  }
  ```
* **適用例**

  ```c
  void example(void) {
      printf("Start\n");
      // 不要なコードは削除
      return;
  }
  ```

---

### ルール2.2：デッドコード

* **逸脱例**

  ```c
  static void unusedFunction(void) {
      // 何も呼び出されない
      printf("使われない関数\n");
  }

  int main(void) {
      printf("メイン処理\n");
  }
  ```
* **適用例**

  ```c
  int main(void) {
      printf("メイン処理\n");
      // unusedFunction は削除
  }
  ```

---

### ルール2.3：未使用の型宣言

* **逸脱例**

  ```c
  typedef struct {
      int x;
      int y;
  } Point;  // Point が使われていない
  ```
* **適用例**

  ```c
  // 未使用の typedef はそもそも定義しない
  ```

---

### ルール2.4：未使用のタグ宣言

* **逸脱例**

  ```c
  struct Data { 
      int a; 
  };  // struct Data が使われていない
  ```
* **適用例**

  ```c
  // 未使用の struct/union タグは定義しない
  ```

---

### ルール2.5：未使用のマクロ宣言

* **逸脱例**

  ```c
  #define MAX(a,b) ((a) > (b) ? (a) : (b))  // マクロ未使用
  ```
* **適用例**

  ```c
  // 未使用のマクロは削除
  ```

---

### ルール2.6：未使用のラベル宣言

* **逸脱例**

  ```c
  void gotoExample(void) {
      int x = 0;
  unused_label:
      x++;
      printf("%d\n", x);
  }
  ```
* **適用例**

  ```c
  void gotoExample(void) {
      int x = 0;
      x++;
      printf("%d\n", x);
  }
  ```

---

### ルール2.7：未使用のパラメータ

* **逸脱例**

  ```c
  void printValue(int value, int unused) {
      printf("%d\n", value);
      // unused は使われていない
  }
  ```
* **適用例**

  ```c
  void printValue(int value, int unused) {
      (void)unused;  // 明示的に未使用を示す
      printf("%d\n", value);
  }
  ```

  ## 2-3. コメント

  | 分類  | グループ   | 項番 | カテゴリ | ガイドライン                                                                            | 詳細                                                                   | 設計思想                          | 検証方法                                     | 備考                       |
|:----:|:---------:|:----:|:--------:|:---------------------------------------------------------------------------------------|:----------------------------------------------------------------------|:---------------------------------|:--------------------------------------------|:--------------------------|
| ルール | コメント | 3.1  | 必要     | 「/*」や「//」という文字の並びをコメント内で使用してはならない                            | コメントの中に誤ってコメント開始・終了シーケンスを書き込むと、ツールが誤解析する恐れがある                         | コメントの正確な区切りを担保          | 静的解析でコメント内の `/*` `*/` `//` 出現を検出   |                            |
| ルール | コメント | 3.2  | 必要     | ラインスプライシングは//コメントで使用してはならない (補足)                              | `//` コメント末尾で `\` を使って次行へつなぐと、コンパイラやツールでの処理が不安定になる                             | コメントの可搬性と解析安定性を確保      | 静的解析で `//.*\\\n`（バックスラッシュ継続）を検出 | 必要なら `/* ... */` を使用 |

## ガイドラインの逸脱例 & 適用例

### ルール3.1：コメント内でのコメント文字列禁止
* **逸脱例**

  ```c
  // このコメント内で /* や // を書いてしまうと…
  // /* 誤って入れた例 */
  // “//” も同様に不可
　```

* **適用例**

  ```c
  /* 説明したい文字列がある場合は、
     コメント内で “/*” や “//” と書かずに
     別の表現を使う */
  /* 例: 「スラッシュ・アスターリスク」と表記 */
  ```

---

### ルール3.2：// コメントでのラインスプライシング禁止

* **逸脱例**

  ```c
  // これは非常に長いコメントなので末尾でバックスラッシュを使って \
  // 次行へつなごうとする例（不可）
  ```
* **適用例**

  ```c
  /* 長いコメントはブロックコメントで記述するか */
  /* 例: これは非常に長いコメントなので、
     ブロックコメントを使って記述します */
  ```


