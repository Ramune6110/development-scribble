## 1. 連続時間PID制御則

制御器出力 $u(t)$ を誤差 $e(t)=r(t)-y(t)$ の関数として

$$
u(t) = K_P\,e(t) + K_I \int_{0}^{t} e(\tau)\,d\tau + K_D \frac{d e(t)}{dt}
$$

と定義します。

* $K_P$: 比例ゲイン
* $K_I$: 積分ゲイン
* $K_D$: 微分ゲイン

---

## 2. 時刻$k$での離散化準備

サンプリング周期を $T_s$ とし、離散時刻を $k$ で表すと、

* 誤差： $e[k]=e(kT_s)$
* 制御入力： $u[k]=u(kT_s)$

### 2.1 積分項の近似

$$
\int_{0}^{kT_s} e(\tau)\,d\tau
\approx \sum_{i=0}^{k} e[i]\,T_s.
$$

累積和を前ステップから更新すると、

$$
I[k]
= \sum_{i=0}^{k} e[i]\,T_s
= I[k-1] + e[k]\,T_s,
\quad I[-1]=0.
$$

### 2.2 微分項の近似

$$
\frac{d e(t)}{dt}\Big|_{t=kT_s}
\approx \frac{e[k] - e[k-1]}{T_s}.
$$

---

## 3. 位置型PID制御（Absolute／Position Form）

積分・微分近似をそのまま代入すると、

$$
u[k]
= K_P\,e[k]
+ K_I\,I[k]
+ K_D \,\frac{e[k] - e[k-1]}{T_s}.
$$

ここで $I[k]=I[k-1]+e[k]T_s$ を用いて、

$$
\boxed{
u[k] = K_P\,e[k]
+ K_I \sum_{i=0}^{k} e[i]\,T_s
+ K_D\,\frac{e[k] - e[k-1]}{T_s}
}
$$

が位置型PIDの標準形です。

---

## 4. 速度型PID制御（Incremental／Velocity Form）

**速度型**では制御量の「変化量」$\Delta u[k] = u[k] - u[k-1]$ を直接計算し、

$$
u[k] = u[k-1] + \Delta u[k]
$$

の形で更新します。では $\Delta u[k]$ を導出します。

### 4.1 $\Delta u[k]$ の定義

$$
\Delta u[k] = u[k] - u[k-1].
$$

### 4.2 それぞれの項の差分

1. **比例項** の差分

   $$
   K_P\,e[k] - K_P\,e[k-1]
   = K_P\,(e[k] - e[k-1]).
   $$

2. **積分項** の差分

   $$
   K_I\,I[k] - K_I\,I[k-1]
   = K_I \bigl(I[k-1] + e[k]T_s - I[k-1]\bigr)
   = K_I\,e[k]\,T_s.
   $$

3. **微分項** の差分

   $$
   K_D\frac{e[k] - e[k-1]}{T_s}
   - K_D\frac{e[k-1] - e[k-2]}{T_s}
   = \frac{K_D}{T_s}\bigl[(e[k]-e[k-1]) - (e[k-1]-e[k-2])\bigr].
   $$

### 4.3 まとめて $\Delta u[k]$ に

これらを足し合わせて、

$$
\begin{aligned}
\Delta u[k]
&= K_P\,(e[k] - e[k-1])
+ K_I\,e[k]\,T_s
+ \frac{K_D}{T_s}\bigl(e[k] - 2e[k-1] + e[k-2]\bigr).
\end{aligned}
$$

したがって、

$$
\boxed{
\begin{aligned}
u[k] &= u[k-1] + \Delta u[k],\\
\Delta u[k]
&= K_P\,(e[k] - e[k-1])
+ K_I\,T_s\,e[k]
+ \frac{K_D}{T_s}\bigl(e[k] - 2e[k-1] + e[k-2]\bigr).
\end{aligned}
}
$$

---

## 5. まとめ：両者の比較

| 項目           | 位置型PID                                                     | 速度型PID                                                                                                     |
| :----------- | :--------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------- |
| **制御則**      | $u[k]=K_P e[k]+K_I\sum e[i]T_s+K_D\frac{e[k]-e[k-1]}{T_s}$ | $u[k]=u[k-1]+\Delta u[k]$、<br>$\Delta u[k]=K_P\Delta e+K_I T_s e[k]+ \frac{K_D}{T_s}(e[k]-2e[k-1]+e[k-2])$ |
| **計算量**      | ・比例・積分・微分を毎ステップ計算<br>・累積和の保持                               | ・変化量のみ計算<br>・過去２ステップ分の誤差保持                                                                                 |
| **初期条件依存性**  | $u[0]$の初期値設定が必要                                            | $\Delta u[0]$・$\Delta u[1]$の初期化が必要                                                                         |
| **メモリ要件**    | 誤差全履歴 or 累積和のみ                                             | 直近の誤差３点のみ                                                                                                  |
| **積分風アップ対策** | 位置型では明示的アンチワインドアップが必要                                      | 自然に累積バイアス軽減効果あり                                                                                            |
| **数値安定性**    | 累積和が大きくなるとオーバーフローの恐れ                                       | 差分形式で大きな値になりにくい                                                                                            |
| **実装の容易さ**   | 最も直感的でチューニングしやすい                                           | 差分形式の導入手順がやや複雑                                                                                             |

* **メリット／デメリット** の観点では、

  * 位置型は「そのままの出力」を計算でき、設計・チューニングが直感的。だが積分項の累積や風アップ（Wind-up）問題の管理が必要。
  * 速度型は「出力変化量」を計算するため累積誤差の暴走が起こりにくく、外乱などへの追従で滑らかな更新が得られる反面、初期条件設定や差分処理がやや複雑になります。

---

混乱されているのは、\*\*「I\[k] が何を表す変数か」\*\*の定義が異なるからです。以下、２通りの書き方を並べてみましょう。

---

## A. 「生の積分値」を状態変数に持つ場合

1. 生の積分値（単位：$\text{error}\times\text{sec}$）を

   $$
   J[k] = \sum_{i=0}^k e[i]\,T_s
   \quad\Longrightarrow\quad
   J[k] = J[k-1] + e[k]\,T_s
   $$

   と定義する。

2. コントロール出力に掛けるゲインは外でまとめて掛ける：

   $$
   u[k] = K_P\,e[k] + K_I\,J[k].
   $$

この場合、確かに

$$
u[k] = K_P e[k] + K_I\bigl(J[k-1] + e[k]T_s\bigr)
       = K_P e[k] + K_I J[k-1] + K_I e[k]T_s
$$

となり、$J[k-1]$ にも毎ステップ $K_I$ が掛かります。

---

## B. 「ゲイン込みの積分項」を状態変数に持つ場合

計算の効率化（掛け算を１回にまとめる）やコード簡素化のために、
「状態変数 $I[k]$ にすでに $K_I$ を掛けた値」を持つ書き方があります。

1. ステップごとに加える分をあらかじめ $k_i = K_I\,T_s$ と定義する。

2. 状態 $I[k]$ を

   $$
   I[k] = I[k-1] + k_i\,e[k]
   $$

   と更新する。
   ここで $I$ の単位は「出力単位」（＝$[K_I]\times[e]\times [T_s]$）になります。

3. コントロール則は

   $$
   u[k] = K_P\,e[k] + I[k].
   $$

この書き方では、既に **「前ステップの積分項 $I[k-1]$ には $K_I$ が掛かった状態で保持されている」** ため、式中で改めて $K_I$ を掛け直す必要がありません。
結果としてユーザーさんが示された

$$
u[k] = K_P\,e[k] + \bigl(k_i\,e[k] + I[k-1]\bigr)
$$

と完全に同義になるわけです。

---

### まとめ

* あなたの式

  $$
    I[k] \;=\; I[k-1] + e[k]\,T_s
  \quad\Longrightarrow\quad
    u[k] = K_P\,e[k] + K_I\,I[k]
  $$

  の書き方（A）では、外側で $K_I$ を掛けるので「前ステップの累積 $I[k-1]$ にも毎回 $K_I$ がかかる」のはそのまま正しい挙動です。

* 一方、実務でよく使う

  $$
    I[k] = I[k-1] + (K_I\,T_s)\,e[k]
  \quad\Longrightarrow\quad
    u[k] = K_P\,e[k] + I[k]
  $$

  の書き方（B）では、状態変数そのものが「$K_I$ を掛けた積分値」を保持しているので、コントロール則に出てくるのは **「I\[k]」だけ**。
  ですから見かけ上は「I\[k-1] にゲインを掛けていない」ように見えますが、実は **保持している値自体にすでにゲインが入っている** のです。

どちらの形式を使っても数値的な動作はまったく同じです。工程としては

1. 生の積分値を持つか
2. ゲイン込みの積分値を持つか

を選ぶだけ、ということになります。

---
はい、そのアイデアは原理的に**妥当**です。以下、ポイントを整理します。

---

## 1. 提案式と標準式の関係

1. **標準的な速度型PI**（Incremental PI）の式を状態変数 $I[k]$ を用いて書くと、

   $$
   \begin{cases}
   I[k] = I[k-1] + K_I\,T_s\,e[k],\\
   u[k] = K_P\,e[k] + I[k].
   \end{cases}
   $$

   すなわち、サンプリングごとの積分分 $K_I T_s e[k]$ を状態変数に足し込む形です。

2. ユーザーさんが見かけた制御則

   $$
   u[k] = K_P\,e[k] + \bigl(k_i\,e[k] + I[k-1]\bigr)
   $$

   と比較すると、まさに

   $$
   k_i = K_I\,T_s,\qquad I[k] = I[k-1] + k_i\,e[k]
   $$

   と定義しているだけであり、**数式的には完全に同等**です。

   * $K_I$（単位：$\text{[出力]}/(\text{[誤差]}\cdot\text{[秒]})$)にサンプリング周期 $T_s$ を掛けたものを
     $\displaystyle k_i = K_I\,T_s$ と再定義
   * 積分状態 $I[k]$ を「既にゲインをかけた値」として持つことで、次ステップの出力にそのまま足し込む

   したがって、

   $$
   I[k] = I[k-1] + k_i\,e[k]
   \quad\Longrightarrow\quad
   u[k] = K_P\,e[k] + I[k]
   $$

   は標準的な位置型PI（Position Form PI）と数値的に同じ挙動になります。

---

## 2. “ハイブリッド”と呼べるか？

* **位置型PID** は「出力そのもの $u[k]$ を直接計算」
* **速度型PID** は「出力の変化量 $\Delta u[k]$ を計算して足し合わせる」

の違いが本質ですが、今回の式では

* **P項** は位置型と同じく「$K_P e[k]$」をそのまま計算
* **I項** は速度型（差分）風に「$\Delta I = k_i e[k]$」を積算

という実装になっており、PとIで手法がミックスされています。
とはいえ、最終的な出力は

$$
u[k]=K_Pe[k]+I[k]
$$

であり、\*\*純粋な「位置型PI」\*\*です。ですから、

> 「Pは位置型、Iは速度型を使った、ハイブリッド形式」

と捉えることはできますが、数学的には**単なる位置型PIの再定式化**にすぎません。

---

## 3. この形式を使うメリット・デメリット

| 項目              | メリット                                 | デメリット                                    |
| :-------------- | :----------------------------------- | :--------------------------------------- |
| **パラメータの分離**    | $k_i=K_I T_s$ として分離でき、サンプリング周期を吸収できる | $T_s$ を変えたら必ず $k_i$ を再チューニングする必要         |
| **実装のシンプルさ**    | 積分計算が「単なる加算 $I[k-1]+k_i e[k]$」で済む    | 積分飽和（Wind-up）対策は依然として必要                  |
| **数値安定性**       | 小さなステップで刻むので急激な大きな変化が起こりにくい          | $k_i$ が大きすぎると発散しやすい                      |
| **チューニング感覚**    | PとIをそれぞれ直感的に調整しやすい                   | 「積分ゲイン $K_I$」と「サンプリング周期 $T_s$」の関係を意識する必要 |
| **拡張性（D項追加など）** | D項も同様に差分形式で実装しやすい                    | 純粋な速度型PID（Δu 直接計算）ほどの「完全な速度型利点」は得にくい     |

---

### 結論

* **妥当性**：提案の式は標準的なPI制御と数式的に同等なので、まったく問題ありません。
* **ハイブリッド性**：Pを位置型、Iを速度型で実装している点で“ハイブリッド風”ですが、全体としては位置型PI制御の一種です。
* **実務的な使いどころ**：

  * サンプリング周期を変えずに一度チューニングしたい
  * コードをシンプルに保ちつつ、速度型の“滑らかな積分”を活かしたい

といった場合に非常に有効なアプローチです。

---

はい、そのとおりです。

* **P 項（比例ゲイン $K_P$）**
  連続時間でも離散時間でも、比例制御は「誤差の瞬時値に比例するだけ」の代数演算です。

  $$
    u_P[k] = K_P\,e[k]
  $$

  ですから、サンプリング周期 $T_s$ が変わっても、$\displaystyle K_P$ 自体は変える必要がありません。

* **I 項（積分ゲイン）**
  連続時間の積分ゲイン $K_I$ を離散化するときには

  $$
    k_i = K_I \,T_s
  $$

  のようにサンプリング周期 $T_s$ を掛けた形で「ステップごとの加算量」を定義します。
  つまり、$\displaystyle T_s$ を変えると $k_i$ が変わらないと、狙った連続時間上の積分効果が得られなくなります。

* **D 項（微分ゲイン）**
  連続時間の微分ゲイン $K_D$ を差分近似で使うときには

  $$
    k_d = \frac{K_D}{T_s}
  $$

  として分母に $T_s$ が現れます。
  したがって、サンプリング周期を変えたらこの $k_d$ も調整しないと、微分作用の強さが変わってしまいます。

---

### まとめ

| 項目      | 離散化後のゲイン定義        | $T_s$ の影響         |
| :------ | :---------------- | :---------------- |
| **P 項** | $K_P$             | 影響なし（そのままで可）      |
| **I 項** | $k_i = K_I\,T_s$  | $T_s$ が変われば再設定が必要 |
| **D 項** | $k_d = K_D / T_s$ | $T_s$ が変われば再設定が必要 |

したがって、おっしゃる通り、**サンプリング周期を変更しても P 項はそのまま、I・D 項だけをサンプリング周期に合わせて調整すればよい**、という理解で正しいです。

---

設計者が P 項だけに「不感帯（デッドゾーン）処理を施し」、I 項には生の誤差を使うのには、主に以下のような狙いがあります。

---

## 1. P 項にデッドゾーンを入れる意図

1. **チョッタリング／振動の抑制**
   セットポイント近傍で $|e[k]|<\Delta$ の小さな誤差が生じても $u_P=K_P\,e$ が発散せず、制御出力の不必要なオン・オフ／微小振動を防ぐ。
2. **ノイズ耐性の向上**
   センサノイズやシステムの微小な振動で生じるゼロ近傍の誤差を「許容」し、制御器が過剰反応しないようにする。

---

## 2. I 項にデッドゾーンを入れない意図

1. **定常偏差（オフセット）の解消**
   デッドゾーン内だけで誤差を止めてしまうと、I 項も動かずに必ず残留偏差（ステディステートエラー）が生じる。
2. **摩擦やヒステリシスへの対応**
   スタティックフリクションやバックラッシュなど、ある程度の力（出力）がないと動き出さない非線形性を、「小さな誤差を積分して徐々に大きな I 項へ変換」することで乗り越える。

---

## 3. P／I の役割分担イメージ

| 項目      | 処理内容                    | 処理対象の誤差    | ねらい                    |
| :------ | :---------------------- | :--------- | :--------------------- |
| **P 項** | $u_P=K_P\,e_{\rm dz}$   | デッドゾーン後の誤差 | ノイズ・チョッタリング抑制          |
| **I 項** | $I[k]=I[k-1]+K_IT_s\,e$ | 生の誤差 $e$   | 定常偏差解消・摩擦／バックラッシュの打ち破り |

* $e_{\rm dz}$ … $|e|<\Delta$ のとき 0、$|e|\ge\Delta$ のとき $e$ を使う
* I 項は常に積算を続け、小さい誤差も逃さずバイアスを溜め込む

---

## 4. 結論

> **P 項：** 小さな誤差への“過剰反応”を防いで安定性・耐ノイズ性を高める
>
> **I 項：** デッドゾーンに逃げ込んだ誤差も確実に積算して、システムの非線形性や定常偏差を打ち破る

――という意図で、P と I に「異なる誤差処理」を適用し、ノイズ耐性と定常偏差解消の両立を図っているわけです。


