https://community.renesas.com/mcu/legacy-mcu/v850/f/v850---forum/16127/exlr-error-small-data-overflow

以下は、リンク先のフォーラム投稿（RenesasコミュニティのV850フォーラム）で議論されている内容と、そこから示される具体的な対策についての解説です。

---

## 1. 議論されている問題の概要

### 問題の内容
- **Small Data Overflow エラー**  
  リンク先では、V850マイコン向けのコンパイラ・リンカで、**small data**（小さなデータ領域）を利用する際に発生する「small data overflow」というエラーについて語られています。  
  - **small data**領域は、アクセス効率を向上させるために、頻繁に使用されるグローバル変数や静的変数などを格納する専用領域です。  
  - この領域は、命令中の即値フィールド（短いオフセットでデータにアクセスするための領域）でアクセスするため、あらかじめ決められたサイズ（たとえば、ある固定ビット幅）内で収める必要があります。

### 具体的な問題点
- **小さなデータ領域に配置される変数が多すぎる場合：**  
  小さなデータ領域に多くの変数が割り当てられると、各変数にアクセスするためのオフセット値が想定より大きくなり、命令中に用意された即値フィールドのビット幅（たとえば23ビット）の範囲を超えてしまいます。
- **結果として発生するエラー：**  
  このオフセットの「オーバーフロー」が原因で、リンカが「exlr error: small data overflow」などのエラーメッセージを出力し、正しくデータへのアクセス命令をエンコードできなくなります。

---

## 2. リンク先で示される具体的な対処法

フォーラム投稿内では、以下のような対策が具体例として議論されています。

### 対策①：Small Data 機能の無効化または制限の変更
- **目的:**  
  小さなデータ領域に変数を割り当てないようにするか、使用する変数の数・サイズを減らすことで、オフセット値が命令フォーマット内に収まるようにする。
- **具体的な方法:**  
  - **コンパイラオプションの変更:**  
    多くの場合、V850向けコンパイラには small data の利用を有効／無効にするオプションが用意されています。  
    例として、`-msmall-data`（有効）や `-mlarge-data`（無効にする）といったオプションが考えられます。  
    これにより、small data領域に自動配置される変数が通常のデータ領域に配置され、オフセット値の制限を回避できます。
    
  - **ソースコードの修正:**  
    もし特定の変数のみ small data に配置されることが問題となっているなら、コンパイラの属性指定や pragma 指令を用いて、該当変数を large data セクションに移動させることも可能です。

### 対策②：リンカスクリプトの調整
- **目的:**  
  コード・データの配置を再検討することで、small data領域とそれに対するアクセスオフセットの距離を短くし、命令フォーマット内に収まるようにする。
- **具体的な方法:**  
  - **セクション配置の最適化:**  
    リンカスクリプトを修正して、small data領域に配置されるセクション（たとえば .sdata や .sbss）が物理メモリ上で連続して、かつ短いオフセットでアクセス可能な位置に配置されるように調整します。
  - **メモリマップの見直し:**  
    メモリ領域の配置を工夫することで、small data領域のサイズを有効に利用できるようにする方法もあります。

### 対策③：不要な変数の削減または関数の分割
- **目的:**  
  small data領域に割り当てられる変数の数やサイズを減らすことで、オフセットオーバーフローを防ぐ。
- **具体的な方法:**  
  - **変数の見直し:**  
    必要以上に small data 領域に割り当てられている変数がないかコードをチェックし、不要な変数を削除または通常のデータ領域へ移動させます。
  - **大きな関数の分割:**  
    大きな関数内で多数の変数が small data に含まれている場合、関数を分割して各関数で扱うデータ量を減らす手法も有効です。

---

## 3. 図解でのイメージ

### ① Small Data Overflow エラーの発生状況

```
[小さなデータ領域のイメージ]
────────────────────────────
| 変数A | 変数B | 変数C | ... | 変数N |
────────────────────────────
    ↑
    ↑
    └─ アクセス時に、各変数までのオフセットが算出される
          （オフセットが大きすぎる場合、即値フィールドに収まらない）
────────────────────────────
         エラー発生：「small data overflow」
```

### ② 対策①：Small Data の無効化

```
[コンパイラオプションによる対策]
────────────────────────────
|   元の設定：small data 有効   |
────────────────────────────
          ↓  オプション変更 (-mlarge-data 等)
────────────────────────────
| small data 機能を無効化し、全データを通常領域に配置 |
────────────────────────────
          ↓
   オフセットオーバーフロー回避
```

### ③ 対策②：リンカスクリプトの調整

```
[リンカスクリプト調整前]
────────────────────────────
| .sdata セクションがメモリ内で離れた位置に配置  |
────────────────────────────
   → アクセスオフセットが長くなる

[リンカスクリプト調整後]
────────────────────────────
| .sdata セクションが連続した短い範囲に配置       |
────────────────────────────
   → オフセットが制限内に収まる
```

---

## 4. まとめ

- **問題:**  
  V850マイコン向けのコンパイル時に、small data領域に配置される変数が多すぎると、命令の即値フィールドに収めるためのオフセット値がオーバーフローし、「exlr error: small data overflow」というエラーが発生する。

- **具体的な対処法:**  
  1. **コンパイラオプションの変更:**  
     - small data の自動配置を無効にする（例：`-mlarge-data` などのオプションを使用）。
  2. **リンカスクリプトの調整:**  
     - small data領域の配置を見直し、オフセットが短くなるようにメモリマップを最適化する。
  3. **コードの見直し:**  
     - 不要な変数を削減する、または関数を分割して small data に含まれるデータ量を抑える。

このような対策を講じることで、small data overflow のエラーを回避し、正しいアドレス計算による命令エンコーディングが可能となります。

---

以上が、リンク先で語られている問題と具体的な対処法の内容になります。  
参考リンク: [Renesas Community – EXLR Error Small Data Overflow](https://community.renesas.com/mcu/legacy-mcu/v850/f/v850---forum/16127/exlr-error-small-data-overflow)

小さなデータ領域（small data area）は、ベースとなるアドレス（ベースレジスタの値）からの相対オフセットで変数にアクセスするため、非常に短い（小さいビット幅の）オフセット値で済むように設計されています。

しかし、この領域に多くの変数を配置すると、以下の理由で各変数にアクセスするためのオフセット値が大きくなることがあります。

---

### 詳細な理由

1. **領域の拡大**
   - **ベースからの距離:**  
     small data領域は、通常、ある特定のベースアドレス（例えば、専用のレジスタが指すアドレス）から連続したメモリ領域として確保されます。もし変数が少なければ、すべての変数はベースから近い位置に配置され、アクセス時に必要なオフセット値は小さくなります。
   - **多くの変数の配置:**  
     一方、多くの変数をsmall data領域に割り当てると、領域全体が広がり、一部の変数はベースから遠い位置に配置されるため、アクセスするための相対距離（オフセット値）が大きくなります。

2. **命令エンコーディングの制約**
   - **即値フィールドのサイズ:**  
     分岐命令やデータアクセス命令において、オフセット値は命令内の即値フィールドにエンコードされます。このフィールドはビット数に制限があるため、格納できる値の範囲も限られています。多くの変数を配置して領域が広がると、ある変数へのアクセスオフセットがこの範囲を超えてしまうリスクが生じます。

---

### 図解による説明

#### ① 少ない変数の場合
```
[小さなデータ領域の例]
Base Address (B)
      │
      ▼
+---------+   ← 変数A (オフセット: +0x00)
|  変数A  |
+---------+
      │
      ▼
+---------+   ← 変数B (オフセット: +0x04)
|  変数B  |
+---------+
      │
      ▼
+---------+   ← 変数C (オフセット: +0x08)
|  変数C  |
+---------+
```
- **解説:**  
  各変数はベースからごく短いオフセットでアクセスでき、即値フィールドに収まる範囲内です。

#### ② 多くの変数の場合
```
[小さなデータ領域の例]
Base Address (B)
      │
      ▼
+---------+   ← 変数A (オフセット: +0x00)
|  変数A  |
+---------+
      │
      ▼
+---------+   ← 変数B (オフセット: +0x04)
|  変数B  |
+---------+
      │
      ▼
   ・・・
      │
      ▼
+---------+   ← 変数Y (オフセット: +0x1F0)
|  変数Y  |
+---------+
      │
      ▼
+---------+   ← 変数Z (オフセット: +0x1F4)
|  変数Z  |
+---------+
```
- **解説:**  
  多くの変数が配置されると、最後の方にある変数（例えば変数Yや変数Z）は、ベースから大きなオフセット（ここでは例として0x1F0、0x1F4）を必要とします。  
  もし命令の即値フィールドが23ビットなど、限られたビット幅しか持たない場合、この大きなオフセットが収まらず、エラー（small data overflow）が発生する可能性があります。

---

### まとめ

- **小さなデータ領域は、**  
  ベースアドレスからの相対オフセットでアクセスするため、変数数が少なければ各変数はベースに近い位置にあり、短いオフセットで済みます。
  
- **しかし、多くの変数を配置すると、**  
  変数の中にはベースから遠い位置に配置されるものも出てきて、アクセスに必要なオフセット値が大きくなり、命令内の即値フィールドのビット幅制限を超えてしまうため、エラーが発生します。

このように、small data領域の利用は効率的なアクセスを可能にする一方、変数数や配置によりオフセット値が大きくなりすぎると、命令フォーマットの制限により問題が起きることがあるのです。

オフセット値とは、**ある基準となるアドレスからの「差分」**、つまり相対的な距離を示す値です。主に以下の目的で使われます。

---

### オフセット値の主な役割

1. **相対アドレッシング**  
   - **目的:**  
     命令が「どこにジャンプするか」や「どのメモリ位置からデータを読み書きするか」を、絶対的なアドレスではなく、ある基準（例えばプログラムカウンタやベースレジスタ）からの相対距離として指定するために使われます。  
   - **例:**  
     分岐命令（ジャンプ命令）は、現在の命令位置からのオフセット値を加えることで、実際のジャンプ先アドレスを計算します。

2. **命令のコンパクト化**  
   - **目的:**  
     絶対アドレスをすべて命令内に入れると、必要なビット数が増えてしまいます。オフセット値を使うことで、限られたビット数で相対的な距離だけを表現でき、命令自体を短く、シンプルに保つことができます。

3. **位置独立コードの実現**  
   - **目的:**  
     オフセット値を使った相対アドレッシングは、プログラムがどこに配置されても正しく動作する「位置独立コード」を実現するのに役立ちます。コードの再配置（リロケーション）の際に、各命令の相対距離が維持されるため、実際のアドレスが変わっても動作に問題が生じません。

---

### 図解による説明

#### 基本的なイメージ

```
    [基準となるアドレス]  ← 例: プログラムカウンタ（PC）やベースレジスタ
             │
             ▼
         +---------+   ← 命令（ジャンプ命令など）
         | Offset  |   ← オフセット値（例えば、+50 とか -20 など）
         +---------+
             │
             ▼
    [計算された実際のアドレス]
```

- **具体例:**  
  もし命令の実行時に、PCが0x1000であり、ジャンプ命令のオフセット値が+0x20（32）であれば、実際のジャンプ先は  
  ```
  0x1000 + 0x20 = 0x1020
  ```
  となります。

---

### まとめ

- **オフセット値とは:**  
  基準アドレスからの相対的な「距離」を示す値です。

- **何のためにいるのか:**  
  - 命令がどの位置へジャンプするか、またはどのメモリ位置からデータをアクセスするかを指定するため。
  - 命令をコンパクトに保ち、位置独立性を確保するため。

このように、オフセット値はプログラム内で効率的にアドレスを指定・計算するための重要な要素なのです。

以下は、修正前のコードと修正後のコードがなぜ違い、なぜ修正後ではコンパイルに成功したのかを解説したものです。

---

## 背景：small data エリアとオフセットの問題

V850 などの組み込み向けプロセッサでは、頻繁にアクセスする変数を高速に扱うために「small data（小さなデータ）エリア」を利用することがあります。このエリア内の変数は、専用のベースレジスタと短い即値（オフセット）を使ってアクセスされます。  
しかし、small data エリアにある変数同士のアクセスでは、**即値フィールドのビット幅**により表現できる相対距離（オフセット）の最大値が決まっています。  
もし、2つの変数間の相対距離がこの範囲を超えると、コンパイラやリンカが「オフセットが収まらない」というエラーを出すことがあります。

---

## 修正前のコード

```c
for (i = 0; i < 7; i++) {
    if (grade == 0U) {
        KFL_LONG[i] = BRK[i];
    }
}
```

### 問題点

- **個別のコピー処理**  
  このコードは、ループ内で配列の各要素を１つずつコピーしています。  
  コンパイラは、各要素アクセスごとに「BRK の要素へのオフセット」と「KFL_LONG の要素へのオフセット」を計算します。

- **small data エリア内の配置によるオフセットの拡大**  
  もし BRK と KFL_LONG が small data エリアに配置されている場合、これらの変数はベースアドレスからの相対位置でアクセスされます。  
  配列の要素は、配列の開始位置からある一定のバイト数ずつ離れた位置に配置されるため、  
  ループ内で各要素へのアクセスは「ベースからのオフセット」を用いて行われます。

- **即値フィールドの制限**  
  リンカは、各アクセス命令のオフセットを即値フィールド（この場合は 23 ビット）に収めようとします。  
  しかし、複数の命令で個々の要素をコピーする際、計算されたオフセット（今回のエラーでは 0x254 ＝ 596）が  
  small data アクセスで許容される範囲や形式に合わず、結果として「オフセット値が 23 ビットに収まらない」というエラーとなりました。

---

## 修正後のコード

```c
if (grade == 0U) {
    KFL_LONG = &BRK[0];
}
```

### なぜ修正後で上手く行ったのか

- **ポインタの単一代入に変更**  
  修正後のコードは、配列の全体を要素ごとにコピーするのではなく、  
  単に **BRK 配列の先頭アドレス**（`&BRK[0]`）を **KFL_LONG** に代入しています。

- **リロケーションの違い**  
  ポインタ代入の場合、コンパイラは単一の定数（アドレス）を扱います。  
  このアドレスのリロケーションは、各要素のアクセスごとに個別のオフセット演算を行うよりも  
  別の（またはより大きなビット幅の）定数として扱われるため、small data の即値フィールドの制限に引っかかることがなくなります。

- **結果として**  
  複数の命令で個々の要素のオフセットを計算する必要がなくなったため、  
  各命令ごとに発生していたオフセットの「オーバーフロー」問題（例：0x254 が収まらない問題）が回避され、  
  正常にコンパイル・リンクできるようになりました。

---

## 図解でのイメージ

### 修正前の処理

```
[BRK 配列の各要素]
   │
   ▼
┌─────────┐    ← 要素 0 (オフセット 0)
│  BRK[0] │
└─────────┘
   │   ↑
   │   │  (小さなデータエリア内で各要素へアクセスする際、ベースからの相対オフセットを計算)
   │   │    → 例：BRK[6] では、ベースからのオフセットが大きくなる
   ▼   │
┌─────────┐    ← 要素 6 (オフセットが大きくなる)
│  BRK[6] │
└─────────┘

→ ループ内で個別の命令として「KFL_LONG[i] = BRK[i]」を行うと、  
　各命令での即値フィールドに計算されたオフセット（例：0x254）が収まらずエラー発生
```

### 修正後の処理

```
    &BRK[0]
       │
       ▼
[BRK 配列の先頭アドレス]
       │
       ▼
  単一のポインタ代入命令 → KFL_LONG にアドレスをそのまま代入
```

→ この場合、複数の命令で細かいオフセット演算を行う必要がなく、  
　リンカも大きな即値を扱う必要がなくなるため、エラーが回避される

---

## まとめ

- **原因:**  
  ループ内で個々の配列要素へのコピー処理を行うと、small data エリア内での変数アクセス時に  
  各要素の相対オフセットが大きくなり、即値フィールド（23 ビット）に収まらないオーバーフローが発生した。

- **修正後の対処法:**  
  配列全体の要素をコピーするのではなく、単一のポインタ代入によって  
  「BRK 配列の先頭アドレス」を直接 KFL_LONG に設定することで、  
  複数の命令でのオフセット演算を避け、リロケーションの問題を回避した。

このように、コピー方法を変更することで、コンパイラが要求する即値フィールドの制約に引っかからなくなり、  
結果として正常にコンパイルが行えるようになりました。
