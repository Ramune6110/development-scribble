	• https://www.docswell.com/s/tyonekubo/5R2Y4E-architecture2design#p1
	• 【Secton1：なぜ設計をするのか？良い設計とは何か？】
		○ 【良い設計】
			§ 上位目的を正しく把握し，それを達成できる（合目的性）
			§ 開発者の認知負荷を下げて，本質的な問題に集中できる
		○ 【上位目的】
			§ ソフトウェアはビジネスを成功に導くために上位目的を達成するものでなくてはならない
			§ 経営理念・ビジョン
			↑
			§ 経営戦略
			↑
			§ IT戦略
			↑
			§ ITシステム
		○ 【認知負荷】
			§ ソフトウェア設計の基本は分けること
			§ 分割理由①
				□ 大きすぎるものは人間の脳にとって認知負荷が高すぎる
				□ Divide and Concur（分割して統治せよ）
			§ 分割理由②
				□ 分割によって生まれる構造と（要素同士の）相互作用が振る舞い以上の力を与える
				□ わかりやすい⇒理解容易性
				□ テストがしやすい⇒テスト容易性
				□ 拡張しやすい⇒拡張性
		○ 【アーキテクチャドライバ】
			§ アーキテクチャを検討する上で重要な考慮事項のこと
			§ アーキテクチャドライバ
				□ 制約（ビジネス上の制約，技術的な制約）
				□ 品質特性
				□ 影響を与える機能要求
				□ その他影響を及ぼすもの
		○ 【アーキテクチャ設計】
			§ アーキテクチャドライバに基づいて最適なアーキテクチャを設計する
			§ ①アーキテクチャによって達成すべきこと（誰のために何の目的で作られるのか）
				□ ビジネス要求
				□ 機能
				□ 品質特性
			§ ②設計判断
				□ 比較評価マトリクス
				□ ADR
			§ ③システムの形状
				□ アーキテクチャモデル
			§ ④文書・規約・ガイドライン
				□ アーキテクチャ記述
				□ 開発規約
				□ チェック
		○ 【品質特性】（JIS X 25010）
			§ 機能適合性
			§ 性能効率性
			§ 互換性
			§ 使用性
			§ 信頼性
			§ セキュリティ
			§ 保守性
			§ 移植性
		○ 【設計の抽象レベル】
			§ アーキテクチャ設計
			↑
			§ モジュール設計
			↑
			§ コンポーネント設計
			↑
			§ クラス設計
			§ 抽象⇔具体
			§ 方針⇔詳細
			§ 全体⇔部分
	• 【Secton2：良い設計をするために大事なことは何か？】
		○ 【設計で大事なこと】
			§ 設計の原理を理解する
			§ 設計原則は上位目的と背後にある設計原理を押さえておくことで，より効果的に使える
		○ 【原理と原則】
			§ 原理：普遍的，根本的な理
			§ 原則：原理によって導かれる，共通的な決まり
		○ 【設計原理】
			§ CLEAN設計原理
			§ 	コードの品質	設計原則
			Cohesive	凝集性	【高凝集】
					分けたものそれぞれの凝集度を高くする
					関連性の高いデータと操作が一か所にぎゅっとまとまっていて，
					余分なものがない状態
			Loosely Coupled	疎結合	【疎結合】
					他の設計要素に対する依存度を弱くする
					・依存する要素数を減らす
					・呼び出す操作を粗粒度にする
					・インターフェースに依存する
			Encapsulated	カプセル化	【抽象化】（方針と詳細の分離）
					設計要素のクライアント（別の設計要素）にとって，
					本質的で重要なものを抽出する（抽象化）
					抽象化されたインターフェースが示す方針と，
					実装の詳細とを分離し，後者はクライアントから隠蔽する
			Assertive	断定的	【関心の分離】
					大きなもの，複雑なものはそのまま取り扱わない
					まずは，関心事によって分離する
			Nonredundant	非冗長	【非冗長】
複数の箇所で繰り返して同じことを行う冗長性があれば取り除く
		○ 【設計原則】
			§ SOLID設計原則
			§ SRP	単一責任の原則	要素にはただ一つの明確な責任を持たせる
			OCP	オープン・クローズドの原則	拡張に対しては開いて，修正に対しては閉じる
			LSP	リスコフの置換原則	派生型はその基本型と置換可能であること
			ISP	インターフェース分離の原則	目的ごとの小さなインターフェースを用意する
			DIP	依存関係逆転の原則	方針から詳細に依存してはならない
			§ SOLID原則の上位目的
			§ 変更に強い設計をするために用いる原則
			§ SRP	変更容易性	変更の影響範囲を局所化する
			OCP	拡張性	振る舞いを追加する際の変更量を極小化する
			LSP	置換可能性	派生型の置き換えを安全に行う
			ISP	変更容易性	変更の影響範囲を局所化する
			DIP	安定性	不安定なモジュール（詳細）の変更の影響が安定なモジュール（方針）に及ぶのを防ぐ
			§ 設計原理の観点でSOLID原則を眺める
			§ SRP	単一責任の原則	【関心の分離】，【高凝集】
			OCP	オープン・クローズドの原則	【抽象化】（方針と詳細の分離）
			LSP	リスコフの置換原則	N/A
			ISP	インターフェース分離の原則	【関心の分離】，【疎結合】
			DIP	依存関係逆転の原則	【抽象化】（方針と詳細の分離），【疎結合】
	• 【Secton３：設計はどのように進めるのがよいか？】
		○ 【設計の進め方】
			§ 全体から部分へ，アウトサイドイン
			§ 設計原理に従って適切に分割する
		○ 【システムアーキテクチャの設計】
			§ ①まずは論理的なユニットとしてのサブシステム分割
				□ 設計原理に従い，関心の分離を行い，高凝集・疎結合を目指す
			§ ②デプロイ単位として物理的にサービス分割し配置決め
				□ マイクロサービス vs モジュラ―モノリス
		○ 【アプリケーションアーキテクチャの設計】
			§ 分割したサービス（アプリケーション）毎に基本構造と分割方針を定める
				□ レイヤード構造
				□ パイプライン構造
			§ レイヤー設計：クリーンなアーキテクチャ
			§ モジュール設計：関心の分離，高凝集
				□ モジュール＝サブシステムを分割した設計要素
				□ 高凝集なモジュール設計のコツ
					® 原則として一種類のアクターに対して，関連度の高いユースケースのセットを提供する
			§ モジュール設計：疎結合，抽象化
			§ コンポーネント設計
				□ モジュールレベルの振る舞い＝ユースケース
				□ 下位レベルのコンポーネントの相互作用によってユースケースの振る舞いを実現する
				□ 入力ポート⇒処理フロー⇒中核ロジック⇒出力ポート
			§ クラス設計（詳細設計）
				□ コンポーネントに割り当てられた振る舞いをより小さく分割し，プログラミング言語の最小単位へ落とし込む
				□ ①ドメイン観点の分割
					® ドメイン知識に基づいた分割
					® 値オブジェクトや区分型（Enum）
					® ID型，ファーストクラスコレクション
				□ ②技術観点の分割
					® デザインパターン＝解決空間の技術制約化で問題解決をうまく行うための定石
		○ 【設計・実装の進め方】
			§ ①ボトムアップ
				□ 依存ツリーの末端のクラスから実装を完成させて統合
				□ 統合のリスク（歪な設計，考慮もれによる手戻り）
			§ ②アウトサイドイン
				□ モックオブジェクトを活用し，外側から実装を進める（実際には行き来）
			§ ③インクリメンタル
				□ ユースケースの一部分を少しずつ，繰り返し統合する
			
![image](https://github.com/user-attachments/assets/5c67d1eb-ba63-4e97-bdcc-76543d049388)
